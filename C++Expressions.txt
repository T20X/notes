Once an rvalue has been bound to a name, it's an lvalue again, whether it's a wrapping type as std::tuple or rvalue references or a plain rvalue reference.
-----------------

An expression is a sequence of operators and operands that specifies a computation.An expression can result in a value and can cause side effects The implementation can regroup operators according to the usual mathematical rules only where the operators really are associative or commutative


************************** Value category **************************

        Each C++ expression(an operator with its operands, a literal,
                            a variable name,
                            etc.) is characterized by two independent properties
    : a type and a value category.Each expression has some non
        - reference type,
    and each expression belongs to exactly one of the three primary value
    categories : prvalue,
    xvalue,
    and lvalue.

        a glvalue(“generalized” lvalue) is an expression whose evaluation
        determines the identity of an object
        or function;
a prvalue(“pure” rvalue) is an expression whose
    evaluation computes the value of an operand of a built
    - in operator(such prvalue has no result object),
    or initializes an object(such prvalue is said to have a result object)
            .The result object may be a variable,
    an object created by new - expression,
    a temporary created by temporary materialization,
    or a member thereof.Note that non - void discarded expressions have a result
                                        object(the materialized temporary)
                                            .Also,
    every
    class and array prvalue has a result object except when it is the operand of
    decltype;
an xvalue(an “eXpiring” value)
    is a glvalue that denotes an object whose resources can be reused;
an lvalue(so - called, historically,
          because lvalues could appear on the left -
              hand side of an assignment expression) is a glvalue that is
    not an xvalue;
an rvalue (so-called, historically, because rvalues could appear on the right-hand side of an assignment expression) is a prvalue or an xvalue.

------------
temporary
------------

The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary objects. [ Note: Temporary objects are materialized

Even when the creation of the temporary object is unevaluated ([expr.context]), all the semantic restrictions shall be respected as if the temporary object had been created and later destroyed ----> EXCEPT <---------- if it used in decltype in that case semantic restrictions dont apply ----> 


Temporary objects are created
- when a prvalue is converted to an xvalue ([conv.rval]),
- when needed by the implementation to pass or return an object of trivially copyable type (see below), and
- when throwing an exception ([except.throw]).


A prvalue of type T can be converted to an xvalue of type T. This conversion initializes a temporary object ([class.temporary]) of type T from the prvalue by evaluating the prvalue with the temporary object as its result object, and produces an xvalue denoting the temporary object. T shall be a complete type.
[Note 1: If T is a class type (or array thereof), it must have an accessible and non-deleted destructor; see [class.dtor]. — end note]
[Example 1:
struct X {
  int n; };
int k = X().n;      // OK, X() prvalue is converted to xvalue


When an implementation introduces a temporary object of a class that has a non-trivial constructor ([class.default.ctor], [class.copy.ctor]), it shall ensure that a constructor is called for the temporary object. Similarly, the destructor shall be called for a temporary with a non-trivial destructor ([class.dtor]). Temporary objects are destroyed as the last step in evaluating the full-expression ([intro.execution]) that (lexically) contains the point where they were created. This is true even if that evaluation ends in throwing an exception. The value computations and side effects of destroying a temporary object are associated only with the full-expression, not with any specific subexpression

If a temporary object has a reference member initialized by another temporary object, lifetime extension applies recursively to such a member's initializer.
[Example 4:
struct S {
  const int &m;
};
const S& s = S{1};     //this is goodpotentially-overlapping subobject

except this! ->>>> 
- A temporary object bound to a reference parameter in a function call ([expr.call]) persists until the completion of the full-expression containing the call.
- A temporary object bound to a reference element of an aggregate of class type initialized from a parenthesized expression-list ([dcl.init]) persists until the completion of the full-expression containing the expression-list.
struct S {
  const int &m;
  S(const int &m) : m(m1) {}
};
const S& s = S(1);     //this is bad, dangling reference!



A temporary bound to a reference in a new-initializer ([expr.new]) persists until the completion of the full-expression containing the new-initializer.
[Note 7: This might introduce a dangling reference. — end note]
[Example 5:
struct S {
  int mi;
  const std::pair<int, int> &mp; };
S a { 1, {2,3} };
S* p = new S{ 1, {2,3} }; // dangling reference

the reason why temporary does not extend its lifetime in new experssion is the fact 


The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary objects.
[Note 3: Temporary objects are materialized:
- when binding a reference to a prvalue ([dcl.init.ref], [expr.type.conv], [ expr.dynamic.cast], [expr.static.cast], [expr.const.cast], [expr.cast]),
- when performing member access on a class prvalue ([expr.ref], [expr.mptr.oper]),
- when performing an array-to-pointer conversion or subscripting on an array prvalue ([conv.array], [expr.sub]),
- when initializing an object of type std​::​initializer_­list<T> from a braced-init-list ([dcl.init.list]),
- for certain unevaluated operands ([expr.typeid], [expr.sizeof]), and
- when a prvalue that has type other than cv void appears as a discarded-value expression


------------------------
TO ALLOW CPU REGISTER OPTIMIZATIONS
----------------------
When an object of class type X is passed to or returned from a function, if X has at least one eligible copy or move constructor ([special]), each such constructor is trivial, and the destructor of X is either trivial or deleted, implementations are permitted to create a temporary object to hold the function parameter or result object. The temporary object is constructed from the function argument or return value, respectively, and the function's parameter or return object is initialized as if by using the eligible trivial constructor to copy the temporary (even if that constructor is inaccessible or would not be selected by overload resolution to perform a copy or move of the object).

--------------------------
Unevaluated expressions
--------------------------
The operands of the operators typeid, sizeof, noexcept, and decltype (since C++11) are expressions that are not evaluated (unless they are polymorphic glvalues and are the operands of typeid), since these operators only query the compile-time properties of their operands. Thus, std::size_t n = sizeof(std::cout << 42); does not perform console output


---------------------
implicit conversions
------
expression e implictily converted to type T if Ts copy initialization is valid. Implicit converions only works at one level

struct A{ 
  A(int){}
  std::string operator() { return "asd";
}
}
;
struct A1 {
  A1(std::string) {}
}

A1 a(3) // will not work as 2 level conversion



-----
initialization
--------

Important take aways:
 - since C++20 direct aggregate initialization is now possible, though it would allow narrowing conversions and won't extend the liftime of a refrence. Something like this is possible now
 struct A { int i; int j;  };  make_shared<A>(1, 2);

 - basically during value initialization if the object's defualt constructor is not user-provider and not deleted and also trivial than zero initialization during value initialization is possible, otherwise the object would be defualt initialized

 - Aggregate initialization would copy initializate explicitly initialized members and direct initializate members with designated initializer, the rest would be initialized as if they were with {}
 

 - expression e implicitly converts to T if copy initialization works -> T a = e;

+++++++++++++++++++++
default initialization
+++++++++++++++++++++
default -> T t;
default->new T;
+++++++++++++++++++++

Default initialization is performed in three situations:

1) when a variable with automatic, static, or thread-local storage duration is declared with no initializer;
2) when an object with dynamic storage duration is created by a new-expression with no initializer;
3) when a base class or a non-static data member is not mentioned in a constructor initializer list and that constructor is called.

The effects of default initialization are:

- if T is a (possibly cv-qualified) class type, the constructors are considered and subjected to overload resolution against the empty argument list. The constructor selected (which is one of the default constructors) is called to provide the initial value for the new object;
NOTE THAT FOR CLASS TYPE IF NO DEFAULT CONSTRUCTOR CAN BE FOUND THEN IT WOULD
    COMPILE ERROR !
- if T is an array type,
    every element of the array is default - initialized;
- else otherwise, no initialization is performed:
  * the objects with automatic / dynamic storage duration(and their subobjects)contain indeterminate values,
  * static and thread - local objects are zero initialized



----------------------- direct initialization  ----------------------

T object(arg);
T object(arg1, arg2, ...);

 T object { arg };  ----> initialization of an object of non-class type with a single brace-enclosed initializer (note: for class types and other uses of braced-init-list, see list-initialization) 
// ----> T object { arg, arga2,... }; - note that these refer to list initialization
 T(other) 
T(arg1, arg2, ...)

 static_cast<T>(other)(4) new T(args, ...)(5) Class::Class()
  : member(args, ...){...}(6)[arg](){...}

      () style direct initialization is more permissive as it allows narrowing
      conversations and using explicit constructors

while direct - initialization considers all constructors and all user -
    defined conversion functions

     The effets of direct initialization are : 
    - If T is an array type the array is initialized as in aggregate initialization, except that narrowing conversions are allowed and any elements without an
    initializer are value
     initialized.A a[2]{A(1)}; // OK: initializes a[0] with A(1) and a[1] with A()
 -

(----> PRETTY MUCH ALLOWS LIMITED AGGREGTE like INITIAZLIATOIN SINCE C++20)
if T is class Type otherwise, if the destination type is a (possibly cv-qualified) aggregate class, it is initialized as described in aggregate initialization except that narrowing conversions are permitted, designated initializers are not allowed, a temporary bound to a reference does not have its lifetime extended, there is no brace elision, and any elements without an initializer are value-initialized.
struct B
{
    int a;
    int&& r;
};
 
int f();
int n = 10;
 
B b1{1, f()};            // OK, lifetime is extended
B b2(1, f());            // well-formed, but dangling reference
B b3{1.0, 1};            // error: narrowing conversion
B b4(1.0, 1);            // well-formed, but dangling reference
B b5(1.0, std::move(n)); // OK

----------------- value initialization ------------------------

   T()
   new T()
   Class::Class(...)
      : member(){...}
   T object{};
(since C++ 11) - BE CAREFULL FOR AGGREGATES IT WOULD CALL AGGREGATE
        INITIALIZATION which has these rules so explicit defult constructors may
        not work !explicit constructors
    and conversion operators wont work in aggregate initialization

    ""
    ""
    "   Otherwise, if the element is not a reference, the element is "
    "copy-initialized from an empty initializer list.  "
    ""
    ""

    T{}
    new T{}(6)(since C++ 11)Class::Class(...)
    : member{} {...}(7)(since C++ 11)

if the empty pair of braces {} is used and T is an aggregate type, aggregate-initialization is performed instead of value-initialization.
Turns into list initialization: If T is a class type that has no default constructor but has a constructor taking std::initializer_list, list-initialization is performed.

Zero- and value-initialization also initialize pointers to their null values

(since C++11)
The effects of value initialization are:

1) if T is a class type with no default constructor  or with user-provided or deleted (since C++11) default constructor, the object is default-initialized;
2) if T is a class type with a default constructor (it can be non-trivial) that is neither user-provided nor deleted (since C++11) (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is zero-initialized and the semantic constraints for default-initialization are checked, and if T has a non-trivial default constructor, the object is default-initialized;
3) if T is an array type, each element of the array is value-initialized;
4) otherwise, the object is zero-initialized.


The standard specifies that zero-initialization is not performed when the class has a user-provided or deleted default constructor, which implies that whether said default constructor is selected by overload resolution is not considered. All known compilers performs additional zero-initialization if a non-deleted defaulted default constructor is selected


++++++++++++++++++
aggregate initialization
++++++++++++++++

T object = { arg1, arg2, ... };
(1) T object{arg1, arg2, ...};
(2)(since C++ 11) T object = {.des1 = arg1, .des2{arg2}...};
(3)(since C++ 20) T object{.des1 = arg1, .des2{arg2}...};	(4)	(since C++20)
(6) T array[N] = {other - sequence}; IMPORTANT -> array just just aggregate class!

all value computations and side effects associated with a given element are sequenced before those of any element that follows it in order of declaration

the way c++ works is that if object is aggregate , aggregate initialization is always been tried on for ither value initialization / list initialization


element is copy-initialized from the corresponding initializer clause of the initializer list:
- If the initializer clause is an expression, implicit conversions are allowed as per copy-initialization, except that narrowing conversions are prohibited (since C++11).
- If the initializer clause is a nested braced-init-list (which is not an expression), list-initialize the corresponding element from that clause, which will (since C++11) recursively apply the rule if the corresponding element is a subaggregate.
- if no value for a given memeber is given then it is copy-initializate with {}

If the aggregate is a union and the initializer list is empty, then If any variant member has a default member initializer, that member is initialized from its default member initializer.(since C++ 11)Otherwise, the first member of the union(if any) is copy  initialized from an empty initializer list.



For a non-union aggregate, each element that is not an explicitly initialized element is initialized as follows:

If the element has a default member initializer, the element is initialized from that initializer.
(since C++11)
Otherwise, if the element is not a reference, the element is copy-initialized from an empty initializer list.
Otherwise, the program is ill-formed.
struct S
{
    int a;
    const char* b;
    int c;
    int d = b[a];
};
 
// initializes ss.a with 1,
//             ss.b with "asdf",
//             ss.c with the value of an expression of the form int{} (that is, 0), <---------------------
//         and ss.d with the value of ss.b[ss.a] (that is, 's')
S ss = {1, "asdf"};


********************* copy initialization *****************************************

Syntax 
(1) T object = other;
(2) f(other)
(3) return other;
(4) throw object;
(5)catch (T object)

---
NARROWING CONVERSIONS ARE allowed
-------

The effects of copy initialization are:

- First, if T is a class type and the initializer is a prvalue expression whose cv-unqualified type is the same class as T, the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object: see copy elision
(since C++17)

- If T is a class type and the cv-unqualified version of the type of other is T or a class derived from T, the non-explicit constructors of T are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.

- If T is a class type, and the cv-unqualified version of the type of other is not T or derived from T, or if T is non-class type, but the type of other is a class type, user-defined conversion sequences that can convert from the type of other to T (or to a type derived from T if T is a class type and a conversion function is available) are examined and the best one is selected through overload resolution. The result of the conversion, which is prvalue expression (since C++17) of the cv-unqualified version of T if a converting constructor was used, is then used to direct-initialize the object. The last step is usually optimized out and the result of the conversion is constructed directly in the memory allocated for the target object, but the appropriate constructor (move or copy) is required to be accessible even though its not used.

- Otherwise (if neither T nor the type of other are class types), standard conversions are used, if necessary, to convert the value of other to the cv-unqualified version of T.

In addition, the implicit conversion in copy-initialization must produce T directly from the initializer, while, e.g. direct-initialization expects an implicit conversion from the initializer to an argument of T's constructor.

struct S { S(std::string) {} }; // implicitly convertible from std::string
S s("abc");   // OK: conversion from const char[4] to std::string
S s = "abc";  // Error: no conversion from const char[4] to S
S s = "abc"s; // OK: conversion from std::string to S
If other is an rvalue expression, a move constructor will be selected by overload resolution and called during copy-initialization. This is still considered copy-initialization; there is no special term (e.g., move-initialization) for this case.

Implicit conversion is defined in terms of copy-initialization: if an object of type T can be copy-initialized with expression E, then E is implicitly convertible to T.

If other is an rvalue expression, a move constructor will be selected by overload resolution and called during copy-initialization. This is still considered copy-initialization; there is no special term (e.g., move-initialization) for this case.


----------------
list initialization
-------------

Direct-list-initialization

T object { arg1, arg2, ... };
(1) T{arg1, arg2, ...}
(2) new T{arg1, arg2, ...}
(3)Class {
  T member{arg1, arg2, ...};
};
(4) Class::Class() : member{arg1, arg2, ...} {
  ...
  (5) Copy - list - initialization

          T object = {arg1, arg2, ...};
  (6) function({arg1, arg2, ...})
  (7) return {arg1, arg2, ...};
  (8) object[{arg1, arg2, ...}]
  (9) object = {arg1, arg2, ...}
  (10)U({arg1, arg2, ...})
  (11) Class {
    T member = {arg1, arg2, ...};
  };	



The effects of list-initialization of an object of type T are:

- If T is an aggregate class and the braced-init-list has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by copy-initialization for copy-list-initialization, or by direct-initialization for direct-list-initialization).

- Otherwise, if T is an aggregate type, aggregate initialization is performed.

- Otherise, if the braced-init-list is empty and T is a class type with a default constructor, value-initialization is performedw.

- Otherwise, the constructors of T are considered, in two phases:
If the previous stage does not produce a match, all constructors of T participate in overload resolution against the set of arguments that consists of the elements of the braced-init-list, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all).

- Otherwise (if T is not a class type), if the braced-init-list has only one element and either T is not a reference type or is a reference type whose referenced type is same as or is a base class of the type of the element, T is direct-initialized (in direct-list-initialization) or copy-initialized (in copy-list-initialization), except that narrowing conversions are not allowed.

a prvalue is generated. The prvalue initializes its result object by copy-list-initialization. The prvalue is then used to direct-initialize the reference (this fails if the reference is a non-const lvalue reference). The type of the temporary is the type referenced by T, unless T is “reference to array of unknown bound of U”, in which case the type of the temporary is the type of x in the declaration U x[] H, where H is the initializer list (since C++20).
(since C++17)

-