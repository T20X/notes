Interrupts: asynchronous interrupts generated by hardware or even software (through traps as they can be part of Interrupt Descriptor Table!)
Exceptions: synchronous interrupts generated by the processor in user/kernel space.  They can be traps,
faults and aborts. all executed fby kernel handler! Note syscalls these days are not interrupts or
exceptions, but a special sys calls syscall/sysret.
Trap resumes control from the next operation - it does not repeat execution! 
Fault tries reexecute the faulty instruction after the handler has been run on the kernel side
Interrups(harware) execute in their own stack!
NMI and other requiring immediatioe attetion interrupts also use their own stack and can be
nested!
Execptions normally execute in the kernel stack!

-----------
on returning from interrupt

If a reschedule is pending:
If the kernel is returning to user-space (that is, the interrupt interrupted a user process), schedule() is called.
If the kernel is returning to kernel-space (that is, the interrupt interrupted the kernel itself), schedule() is called only if the preempt_count is zero (see kernel preemption). Otherwise it is not safe to preempt the kernel.
After schedule() returns, or if there is no work pending, the initial registers are restored and the kernel resumes whatever was interrupted.


-------------------
As described, the kernel processes softirqs in a number of places, most commonly on return from handling an interrupt. There are two characteristics with softirqs:

Softirqs might be raised at high rates, such as during heavy network traffic.
Softirq functions can reactivate themselves. That is, while running, a softirq can raise itself so that it runs again. For example, the networking subsystem's softirq raises itself.

The solution ultimately implemented in the kernel is to not immediately process reactivated softirqs. Instead, if the number of softirqs grows excessive, the kernel wakes up a family of kernel threads to handle the load. The kernel threads run with the lowest possible priority (nice value of 19), which ensures they do not run in lieu of anything important. The advantage it brings are:

The concession prevents heavy softirq activity from completely starving user-space of processor time.
It also ensures that excessive softirqs do run eventually.
On an idle system the softirqs are handled rather quickly because the kernel threads will schedule immediately.

---------------------------
In the new machines there is an Advanced Programmable Interrupt Controller commonly known as - APIC.
 An APIC consists of two separate devices:
Local APIC
I/O APIC

The first - Local APIC is located on each CPU core. The local APIC is responsible for handling 
the CPU-specific interrupt configuration. The local APIC is usually used to manage interrupts from the APIC-timer, thermal sensor and any other such locally connected I/O devices.

The second - I/O APIC provides multi-processor interrupt management. It is used to distribute external
 interrupts among the CPU cores
---------------------
 APIC represents a series of devices and technologies that work together to generate, route, and handle a large number of hardware interrupts in a scalable and manageable way. It uses a combination of a local APIC built into each system CPU, and a number of Input/Outpt APICs that are connected directly to hardware devices. When a hardware device generates an interrupt, it is detected by the IO-APIC it is connected to, and then routed across the system APIC bus to a particular CPU. The operating system knows which IO-APIC is connected to which device, and to which particular interrupt line within that device because of a combination of information sources. Firstly, there is the ACPI DSDT (Advanced Configuration and Power Interface Differentiated System Description Table) that includes information about the specific wiring of the host system motherboard and peripheral components. Secondly, a device provides certain information about its available interrupt sources. Together, these two sets of data provide information about the overall interrupt hierarchy.

----------------------
If the interrupt (Non-maskable alike) happens when running in user mode, 
actually two stack switches occur: first from the user stack to the kernel stack for that 
thread/process (this is done automatically by the hardware), 
then the switch to the interrupt stack. See 
--------------
When interrupts are enabled, receipt of an IRQ prompts a switch to interrupt context. Kernel interrupt dispatch code retrieves the IRQ number and its associated list of registered Interrupt Service Routines (ISRs), and calls each ISR in turn. The ISR acknowledges the interrupt and ignores redundant interrupts from the same IRQ, then queues a deferred handler to finish processing the interrupt and stop the ISR from ignoring future interrupts
-------------
-----
If an interrupt or exception handler is called through an interrupt gate, the processor clears the interrupt enable (IF) flag in the EFLAGS register to prevent subsequent interrupts from interfering with the execution of the handler. An ISR has to be atomic and no one should be able to preempt the ISR. So all the interrupts are disabled on local CPU except NMI. When a given interrupt handler is executing, the corresponding interrupt line is masked out on all processors, preventing another interrupt on the same line from being received. Normally all other interrupts are enabled on other CPUs
------------
TSS (Task State Segment) - hardware struct per process!
Linux just uses it per CPU and all the processes share it (including kernel)!

This containns!
The stack pointer addresses for each privilege level.
Pointer Addresses for the Interrupt Stack Table (The inner-level stack pointer section above, discusses the need for this).
Offset Address of the IO permission bitmap


Kernel stacks on x86-64 bit
---------------------------

Most of the text from Keith Owens, hacked by AK

x86_64 page size (PAGE_SIZE) is 4K.

Like all other architectures, x86_64 has a kernel stack for every
active thread.  These thread stacks are THREAD_SIZE (2*PAGE_SIZE) big.
These stacks contain useful data as long as a thread is alive or a
zombie. While the thread is in user space the kernel stack is empty
except for the thread_info structure at the bottom.

In addition to the per thread stacks, there are specialized stacks
associated with each CPU.  These stacks are only used while the kernel
is in control on that CPU; when a CPU returns to user space the
specialized stacks contain no useful data.  The main CPU stacks are:

* Interrupt stack.  IRQ_STACK_SIZE

  Used for external hardware interrupts.  If this is the first external
  hardware interrupt (i.e. not a nested hardware interrupt) then the
  kernel switches from the current task to the interrupt stack.  Like
  the split thread and interrupt stacks on i386, this gives more room
  for kernel interrupt processing without having to increase the size
  of every per thread stack.

  The interrupt stack is also used when processing a softirq.

Switching to the kernel interrupt stack is done by software based on a
per CPU interrupt nest counter. This is needed because x86-64 "IST"
hardware stacks cannot nest without races.

x86_64 also has a feature which is not available on i386, the ability
to automatically switch to a new stack for designated events such as
double fault or NMI, which makes it easier to handle these unusual
events on x86_64.  This feature is called the Interrupt Stack Table
(IST).  There can be up to 7 IST entries per CPU. The IST code is an
index into the Task State Segment (TSS). The IST entries in the TSS
point to dedicated stacks; each stack can be a different size.

An IST is selected by a non-zero value in the IST field of an
interrupt-gate descriptor.  When an interrupt occurs and the hardware
loads such a descriptor, the hardware automatically sets the new stack
pointer based on the IST value, then invokes the interrupt handler.  If
the interrupt came from user mode, then the interrupt handler prologue
will switch back to the per-thread stack.  If software wants to allow
nested IST interrupts then the handler must adjust the IST values on
entry to and exit from the interrupt handler.  (This is occasionally
done, e.g. for debug exceptions.)

These interrupts can be nested! NMI can just keep execution and stacking on the same
stack!

The currently assigned IST stacks are :-

* DOUBLEFAULT_STACK.  EXCEPTION_STKSZ (PAGE_SIZE).

  Used for interrupt 8 - Double Fault Exception (#DF).

  Invoked when handling one exception causes another exception. Happens
  when the kernel is very confused (e.g. kernel stack pointer corrupt).
  Using a separate stack allows the kernel to recover from it well enough
  in many cases to still output an oops.

* NMI_STACK.  EXCEPTION_STKSZ (PAGE_SIZE).

  Used for non-maskable interrupts (NMI).

  NMI can be delivered at any time, including when the kernel is in the
  middle of switching stacks.  Using IST for NMI events avoids making
  assumptions about the previous state of the kernel stack.


--------------
I wrote a small test-program to pinpoint this more exactly,
 and it's interesting. On my Haswell CPU, the cost of a single page fault 
seems to be about 715 cycles. The "iret" to return is 330 cycles. So just
 the page fault and return is about 1050 cycles. That cost might be off by 
some small amount, but it's close. On another test case, I got a number that was
 in the 1150 cycle range, but that had more noise, so 1050 seems to be the minimum cost.

