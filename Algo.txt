bool operator<(const Solution::Position& left, const Solution::Position& right)
{
    return left.x < right.x || ((left.x == right.x) && left.y < right.y);
}

---------------------
Inplace merge of two sorted subarrays
---------
void merge(int arr[], int start, int mid, int end) 
{ 
    int start2 = mid + 1; 
  
    // If the direct merge is already sorted 
    if (arr[mid] <= arr[start2]) { 
        return; 
    } 
  
    // Two pointers to maintain start 
    // of both arrays to merge 
    while (start <= mid && start2 <= end) { 
  
        // If element 1 is in right place 
        if (arr[start] <= arr[start2]) { //arr[start2] < arr[start])
            start++; 
        } 
        else { 
            int value = arr[start2]; 
            int index = start2; 
  
            // Shift all the elements between element 1 
            // element 2, right by 1. 
            while (index != start) { 
                arr[index] = arr[index - 1]; 
                index--; 
            } 
            arr[start] = value; 
  
            // Update all the pointers 
            start++; 
            mid++; 
            start2++; 
        } 
    } 
} 
--------------
Greedy algorthim requrore local solution to be also globally optimal. It is always hard to prove that is the case.

--------------
Sliding Window
--------------
(1)Fast/Slow - fast pointers greedly is trying to get the window by moving the front pointer. once condition is satified then the back pointer is catching up with the fast pointer one step a type to remove potentially not required items!
Minimum Window Substring problem for example.
(2) Fast/Catchup pointer  - keep moving the fast pointer as window condition keeps filling up and then once it is not longer valid jump the slow pointer right to it to catch up - Max consecutive Sum problem
(3) Fast/Lagging - fast pointer keep moving and there are many other pointer behing it tracking other possible states
Problem : House Robber
(4)  Front/Back - you have one pointer travelling from the front and other from the back
Problem: Rainwater Problem




---------------------
Selection algorithm
-------------------
  function select(list, left, right, k)
     if left = right        // If the list contains only one element,
         return list[left]  // return that element
     pivotIndex  := ...     // select a pivotIndex between left and right,
                            // e.g., left + floor(rand() % (right - left + 1))
     pivotIndex  := partition(list, left, right, pivotIndex)
     // The pivot is in its final sorted position
     if k = pivotIndex
         return list[k]
     else if k < pivotIndex
         return select(list, left, pivotIndex - 1, k)
     else
         return select(list, pivotIndex + 1, right, k)
----
Graphs
---
(1) DFS marks node as visited before considering other nodes. BFS marks the node as visited only after considering other nodes

-------
Backtracking
-------

    template <typename F>
    void backtrack_(int k, int n, std::vector<int>& input, const F& f)
    {
        if (solution_found_(k, n, input))
            f(input);
        else
        {
            vector<Turn> c;
            construct_candaidtes_(c, k, n, input);
            if (!c.empty())
            {
                k = k + 1;
                for (const auto& t : c)
                {
                    make_move(input, k - 1, t);
                    backtrack_(k, n, input, f);
                    unmake_move(input, k - 1, t);
                }
            }
        }
    }
The backtracking algorithm enumerates a set of partial candidates that, in principle, could be completed in various ways to give all the possible solutions to the given problem. The completion is done incrementally, by a sequence of candidate extension steps.

Conceptually, the partial candidates are represented as the nodes of a tree structure, the potential search tree. Each partial candidate is the parent of the candidates that differ from it by a single extension step; the leaves of the tree are the partial candidates that cannot be extended any further.

The backtracking algorithm traverses this search tree recursively, from the root down, in depth-first order. At each node c, the algorithm checks whether c can be completed to a valid solution. If it cannot, the whole sub-tree rooted at c is skipped (pruned). Otherwise, the algorithm (1) checks whether c itself is a valid solution, and if so reports it to the user; and (2) recursively enumerates all sub-trees of c. The two tests and the children of each node are defined by user-given procedures.

Therefore, the actual search tree that is traversed by the algorithm is only a part of the potential tree


root(P): return the partial candidate at the root of the search tree.
reject(P,c): return true only if the partial candidate c is not worth completing.
accept(P,c): return true if c is a solution of P, and false otherwise.
first(P,c): generate the first extension of candidate c.
next(P,s): generate the next alternative extension of a candidate, after the extension s.
output(P,c): use the solution c of P, as appropriate to the applicati

procedure bt(c)
  if reject(P,c) then return
  if accept(P,c) then output(P,c)
  s ? first(P,c)
  while s != NULL do
    bt(s)
    s ? next(P,s)

-------------
Dejkstra
---------

    // walktrhough helpers
    std::priority_queue<DijkstraQItem> Q;
    std::set<char> visited;  

    // start from the source vertex
    Q.push({ source, 0 }); 
    p[index(source)] = 0;
    d[index(source)] = 0;    

    while (!Q.empty())
    {
        DijkstraQItem current = Q.top();
        Q.pop();

        unsigned y = index(current.vertex);        
        
        // discover(NOT visit!) all adjacent vertecies
        for (unsigned x = 0; x < _N_; x++)
        {   
            // only consider if adjacent vertex was not visited before
            if (graph[y][x] == _edge_missing_ || visited.find(vertex(x)) != visited.end())
                continue;            

            // make sure adjacent vertices got 
            // shortest distance from the source vertex
            unsigned dTx = d[y] + graph[y][x];
            if (dTx < d[x])
            {
                d[x] = dTx; 
                p[x] = current.vertex;
            }

            // add unvisited adjacent vertices to Q
            Q.push({vertex(x), d[x]});
        }

        visited.insert(current.vertex);
    }

