----
Graphs
---
(1) DFS marks node as visited before considering other nodes. BFS marks the node as visited only after considering other nodes

-------
Backtracking
-------

The backtracking algorithm enumerates a set of partial candidates that, in principle, could be completed in various ways to give all the possible solutions to the given problem. The completion is done incrementally, by a sequence of candidate extension steps.

Conceptually, the partial candidates are represented as the nodes of a tree structure, the potential search tree. Each partial candidate is the parent of the candidates that differ from it by a single extension step; the leaves of the tree are the partial candidates that cannot be extended any further.

The backtracking algorithm traverses this search tree recursively, from the root down, in depth-first order. At each node c, the algorithm checks whether c can be completed to a valid solution. If it cannot, the whole sub-tree rooted at c is skipped (pruned). Otherwise, the algorithm (1) checks whether c itself is a valid solution, and if so reports it to the user; and (2) recursively enumerates all sub-trees of c. The two tests and the children of each node are defined by user-given procedures.

Therefore, the actual search tree that is traversed by the algorithm is only a part of the potential tree


root(P): return the partial candidate at the root of the search tree.
reject(P,c): return true only if the partial candidate c is not worth completing.
accept(P,c): return true if c is a solution of P, and false otherwise.
first(P,c): generate the first extension of candidate c.
next(P,s): generate the next alternative extension of a candidate, after the extension s.
output(P,c): use the solution c of P, as appropriate to the applicati

procedure bt(c)
  if reject(P,c) then return
  if accept(P,c) then output(P,c)
  s ? first(P,c)
  while s != NULL do
    bt(s)
    s ? next(P,s)

-------------
Dejkstra
---------

    // walktrhough helpers
    std::priority_queue<DijkstraQItem> Q;
    std::set<char> visited;  

    // start from the source vertex
    Q.push({ source, 0 }); 
    p[index(source)] = 0;
    d[index(source)] = 0;    

    while (!Q.empty())
    {
        DijkstraQItem current = Q.top();
        Q.pop();

        unsigned y = index(current.vertex);        
        
        // discover(NOT visit!) all adjacent vertecies
        for (unsigned x = 0; x < _N_; x++)
        {   
            // only consider if adjacent vertex was not visited before
            if (graph[y][x] == _edge_missing_ || visited.find(vertex(x)) != visited.end())
                continue;            

            // make sure adjacent vertices got 
            // shortest distance from the source vertex
            unsigned dTx = d[y] + graph[y][x];
            if (dTx < d[x])
            {
                d[x] = dTx; 
                p[x] = current.vertex;
            }

            // add unvisited adjacent vertices to Q
            Q.push({vertex(x), d[x]});
        }

        visited.insert(current.vertex);
    }

