    int root(sqrt(n)));
    return n == root * root
This won't always work, due to floating-point error: if sqrt() or cbrt() happens to return epsilon less than the actual root, the cast to an integer will truncate that, and the check will fail. To be completely bullet-proof against that, you also need to check if n == (root + 1) * (root + 1) for the square root case or if n == (root + 1) * (root + 1) * (root + 1) for the cube root cas
--------

https://www.youtube.com/watch?time_continue=23&v=mKJiD2ZAlwM - add two numbers!

123.45 = 0.12345 × 10+3. - true normalized form
a/b (b - denominator)
1/1000

Significand Exponent Scientific notation Fixed-point value
1.5 4 1.5 104 15000

Single precision Double precision
Total bits 32 64
Sign bits 1 1
Significand bits 23 52
Exponent bits 8 11
Smallest number 2-126 ˜ 1.2 × 10-38 2
-1022 ˜ 2.2 × 10-308
Largest number ca. 2 × 2
127 ˜ 3.4 × 1038 ca. 2 × 2
1023 ˜ 1.8 × 10308

The actual bit sequence is the sign bit first, followed by the exponent and finally the
significand bits.
• The exponent does not have a sign; instead an exponent bias is subtracted from it (127
for single and 1023 for double precision). This, and the bit sequence, allows floating-point
numbers to be compared and sorted correctly even when interpreting them as integers.
• The significand’s most significant bit is assumed to be 1 and omitted, except for special cases.
• There are separate positive and a negative zero values, differing in the sign bit, where all
other bits are 0. These must be considered equal even though their bit patterns are different.
• There are special positive and negative infinity values, where the exponent is all 1-bits and
the significand is all 0-bits. These are the results of calculations where the positive range of
the exponent is exceeded, or division of a regular number by zero.
• There are special not a number (or NaN) values where the exponent is all 1-bits and the
significand is not all 0-bits. These represent the result of various undefined calculations (like
multiplying 0 and infinity, any calculation involving a NaN value, or application-specific
cases). Even bit-identical NaN values must not be considered equal.



While the errors in single floating-point numbers are very small, even simple calculations on them
can contain pitfalls that increase the error in the result way beyond just having the individual errors
“add up”.
In general:
• Multiplication and division are “safe” operations
• Addition and subtraction are dangerous, because when numbers of different magnitudes are
involved, digits of the smaller-magnitude number are lost.
• This loss of digits can be inevitable and benign (when the lost digits also insignificant for the
final result) or catastrophic (when the loss is magnified and distorts the result strongly).
• The more calculations are done (especially when they form an iterative algorithm) the more
important it is to consider this kind of problem.
12
5 APENDIX
• A method of calculation can be stable (meaning that it tends to reduce rounding errors) or
unstable (meaning that rounding errors are magnified). Very often, there are both stable and
unstable solutions for a problem.