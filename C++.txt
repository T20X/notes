The overloads that do not use std::piecewise_construct_t assume that each tuple argument becomes the element of a pair. The overloads that use std::piecewise_construct_t assume that each tuple argument is used to construct, piecewise, a new object of specified type, which will become the element of the pair
------------------------
std::forward_as_tuple
std::tie - Creates a tuple of lvalue references to its arguments or instances of std::ignore.

----------

----------
const Fred& operator[] (unsigned index) const;  // Subscript operators often come in pairs
  Fred&       operator[] (unsigned index);        // Subscript operators often come in pai
----------
Sometimes it's safe to throw an exception even while std::uncaught_exception() == true. For example, if stack unwinding causes an object to be destructed, the destructor for that object could run code that throws an exception as long as the exception is caught by some catch block before escaping the destructor.

----------
template <typename... Args>
void print_size(Args... args)
{
  cout << sizeof...(args) << endl;
}

int main(void)
{
  print_size(); // outputs 0
  print_size("Is the answer", 42, true); // outputs 3
}

---------
CERT coding standart
https://wiki.sei.cmu.edu/confluence/display/cplusplus/2+Rules


-------------
lambdas diffrences between C++11 and C++14
-------------
In C++14 all of these possible.

Move example:

auto f1 = [v = std::move(v)](auto arg) { f(42, arg, std::move(v)); };
Expression example:

auto f1 = [sum = a + b](auto arg) { f(42, arg, sum); };
See question

Perfect forwarding: You can write

auto f1 = [=](auto&& arg) { f(42, std::forward<decltype(arg)>(arg)); };

----------------
copy elision
(RVO, no copy/move of thrown/catch objects if they have no-sideeffects)

----------------
move semantics
--------------
std::vector has an overload for a const A & and a A &&, so the overload with const A & will get chosen and the const A && is implicitly casted to const A &

(1) const objects cannot be moved, copy construct will be called
(2) only one of these functions can be declared
    void f(Base other)
    void f(Base&& other)
(3) Remember that “&&” indicates a universal reference only where type deduction takes place

universal ref: ->
template<typename T>
void f(T&& param); 

not universal ref ->
template<typename T>
void f(vector<T>&& param); 

Universal references can only occur in the form “T&&”!  Even the simple addition of a const qualifier is enough to disable the interpretation of “&&” as a universal referenc
 
(4)  && has preference when taking a temporary Base() as input, then template<T>(T&&), then const Base&! coz overloading has a precedence over templates!
    void f(const Base& other) 
    void f(Base&& other) 
    template <typename T> void f(T&& other) {}
    void f(const Base&& other)

(5) C++ does not guarantee any order for the evaluation of function arguments

(6) exception is a virtual class


(7) The lifetime of the temporary may be extended by binding a reference to it (in which case its lifetime is extended until the end of the lifetime of the reference), or by using it as an initializer in a constructor's initializer list (in which case its lifetime is extended until the object being constructed is fully constructed).

Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. This is true even if that evaluation ends in throwing an exception

(8) TEMPLATE CANNOT BE COPY CONSTRUCTOR! That is why when declaring template copy and assinge operators, also need to declare default ones as well!

(9) std::shared_ptr<int> sp( new int[10], std::default_delete<int[]>() );
     std::shared_ptr<std::array<int,6>> ptr(std::make_shared<std::array<int, 6>>(std::array<int, 6>()));

(10)
std::string get_string() {
    return std::string();
}

BOTH ARE NOT EQUAL
std::string get_string() {
    return {}; // an empty string is returned
}

If T is an aggregate, then each member is initialized from its brace-or-equal-initializer if it had one, otherwise as if by {} (so apply these steps recursively).
If T is a class type with a user-provided default constructor, that constructor is called.
If T is a class type with an implicitly-defined, or = defaulted default constructor, the object is zero-initialized and then the default constructor is called.
If T is a std::initializer_list, the return value is an empty such list.
Otherwise (i.e. T is a non-class type -- return types cannot be arrays), the return value is zero-initialized


(11) constructors can be chained
A(int)
A(int,int):A(int)!
  
(12) if (this != _STD addressof(_Right))

(13) make_transform_iterator
     make_filter_iterator

(14) default parameters are re-evaluated on each call!
     void f(const A& a = Time::now())
     ....
     f(Time::now())
     f(Time::now())

     for virtual functions default parameters are taken from the type it is bein syntactically 
     called from.

(15) Captureless lamba types are implicitly convertetable to function pointer type. However + is needed for it to happen
     template <typename R, typename A>
     void foo(R (*fptr)(A)) { puts(__PRETTY_FUNCTION); }
     foo( [](double x) { return int(x); } // WRONG!
     foo( +[](double x) { return int(x); } //CORRECT

(16) declare stack variables as auto
      auto a = type;
      auto b = type_final { type}

(17) in C++98 throw() would cause the stack to unwind for the caller of it, but from c++11
     noexcept() does not require that and program can terminatate!

(18) struct Point
     {
	constexpr Point(int x, int y):x_(x), y_(y) {}
	constexpr getX() { return x_; }
	constexpr getY() { return x_; }
        constexpr setX(int x) noexcept { x_ = x; }
        constexpr setY(int y) noexcept { y_ = y; }
     };
     }

(19) struct A {
     A(int x) { }
     private:
     A(A const&); };


    A f() {
  return { 10 };
}

(20) You can have UTF-8 strings, Raw strings and more. Here I want to show raw strings. We define a raw string as below:

string s = R"(Hello, World!)"; // Stored: "Hello, World!"
A raw string skips all escape characters like \n or \". e.g.

string str = "Hello\tWorld\n";
string r_str = R"(Hello\tWorld\n)";
cout << str << r_str;
Output:

Hello	World
Hello\tWorld\n
You can also have multiple line raw string:

string r_str =
R"(Dear Programmers,
I'm using C++11
Regards, Swift!)";
cout << r_str;

(21) Use std::addressof instead of & to get an address in templated code since & operator can be overloaded and hence a proper address of an object may not be retrieved!

(22)
Padding aligns structure members to "natural" address boundaries - say, int members would have offsets, which are mod(4) == 0 on 32-bit platform. Padding is on by default. It inserts the following "gaps" into your first structure:

struct mystruct_A {
    char a;
    char gap_0[3]; /* inserted by compiler: for alignment of b */
    int b;
    char c;
    char gap_1[3]; /* -"-: for alignment of the whole struct in an array */
} x;
Packing, on the other hand prevents compiler from doing padding - this has to be explicitly requested - under GCC it's __attribute__((__packed__)), so the following:

struct __attribute__((__packed__)) mystruct_A {
    char a;
    int b;
    char c;


(23) 

vector::push_back
If the new size() is greater than capacity() then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated

};

(24)
copy constructor that accepts const T& arguments, satisfy std::is_move_constructible
copy assingment that accepts constT& argument satifsfy std::is_move_assingable!

(25)
The operands of the operators typeid, sizeof, noexcept, and decltype (since C++11) 
are expressions that are not evaluated (unless they are polymorphic glvalues and
 are the operands of typeid), since these operators only query the
 compile-time properties of their operands.
 Thus, std::size_t n = sizeof(std::cout << 42);
 does not perform console output

(26)
variadic functions copy values!!!!
drainByCopy(...)
A a;drainByCopy(a) -> A MUST have a copy constructor!