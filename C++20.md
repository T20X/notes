# reference_wrapper

now can contains incomplete types !

# ranges

[link](./C++20Ranges.md)

# variant

The class template std::variant represents a type-safe union. An instance of std::variant at any given time either holds a value of one of its alternative types, or in the case of error - no value (this state is hard to achieve, see valueless_by_exception).

As with unions, if a variant holds a value of some object type T, the object representation of T is allocated directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory.

A variant is not permitted to hold references, arrays, or the type void. Empty variants are also ill-formed (std::variant<std::monostate> can be used instead).

A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.

Consistent with the behavior of unions during aggregate initialization, a default-constructed variant holds a value of its first alternative, unless that alternative is not default-constructible (in which case the variant is not default-constructible either). The helper class std::monostate can be used to make such variants default-constructible.

## vs virtual functions / inherentence

it is faster for two reasons:

- the variant version doesn’t use dynamic memory allocation, so all the particles are in the same memory block. CPUs can leverage this to get better performance.
- visitor can be inlined fully! so no need to call a function...

## holds_alternative


template< class T, class... Types >
constexpr bool holds_alternative( const std::variant<Types...>& v ) noexcept;
(since C++17)
Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Types.


## valueless_by_exception

constexpr bool valueless_by_exception() const noexcept;

A variant may become valueless in the following situations:

(guaranteed) an exception is thrown during the initialization of the contained value during move assignment
(optionally) an exception is thrown during the initialization of the contained value during copy assignment
(optionally) an exception is thrown when initializing the contained value during a type-changing assignment
(optionally) an exception is thrown when initializing the contained value during a type-changing emplace
Since variant is never permitted to allocate dynamic memory, previous value cannot be retained in these situations. The situations marked "optionally" can be worked around by implementations that first construct the new value on the stack and then move it into the variant (provided non-throwing move).

This applies even to variants of non-class types:

struct S {
    operator int() { throw 42; }
};

std::variant<float, int> v{12.f}; // OK
v.emplace<1>(S()); // v may be valueless
A variant that is valueless by exception is treated as being in an invalid state: index returns variant_npos, get and visit throw bad_variant_access.

# std::span

The class template span describes an object that can refer to a contiguous sequence of objects with the first element of the sequence at position zero. A span can either have a static extent, in which case the number of elements in the sequence is known at compile-time and encoded in the type, or a dynamic extent. Span is both range and a VIEW!

If a span has dynamic extent, a typical implementation holds two members: a pointer to T and a size. A span with static extent may have only one member: a pointer to T

 std::span has no comparison operators

# concepts

 * Non-formal definition -> Concept allows us to control the instantiation of templates by testing syntactic conditions, but testing syntactic conditions. SFINAE on steroids

 * A concept is a named set of requirements.The definition of a   concept must appear at namespace scope   concepts are like compile time predicate
  and farily the same can be said about constraints,  but concepts emobyd semantics(meaning).
  Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint.

 * Violations of constraints are detected at compile time, early in the template instantiation process,
  which leads to easy to follow error message. The intent of concepts is to model semantic categories(Number, Range, RegularFunction)
   rather than syntactic restrictions(HasPlus, Array) - The ability to specify a
    meaningful semantics is a defining characteristic of a true concept,
    as opposed to a syntactic constrain

    Say Sorteable is concept,
    but constraint is say Subtractable,
    Incrementable

    // Concepts cannot recursively refer to themselves and cannot be constrained
    template <class T, class U>
    concept Derived = std::is_base_of<U, T>::value;
template <typename T>
concept Hashable = requires(T a) {
  { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>;
};

template <C1 T>
concept Error1 = true; // Error: C1 T attempts to constrain a concept definition
template <class T>
requires C1<T>
concept Error2 =
    true; // Error: the requires-clause attempts to constrain a concept

Explicit instantiations, explicit specializations,
    or partial specializations of concepts
                are not allowed(the meaning of the original definition of a
                                    constraint cannot be changed)
                    .

            ................

            The keyword requires is used to introduce a requires -
            clause,
    which specifies constraints on template arguments or
        on a function declaration

            the keyword requires must be followed by some constant
            expression(so its possible to write requires true), but the intent is that a named concept (as in the example above) or a conjunction/disjunction of named concepts or a requires-expression is used



 * Concepts can be part of template
```
  template <Addable T>
  void f(const T& t) {  
  }
```

 * Concepts can be just used with auto
```
auto f(Addable cont auto const& v) {
}
```

* Concep can be just defined as simple exprssions as well
```
 template< class T, class... Args >
concept constructible_from =
    std::destructible<T> && std::is_constructible_v<T, Args...>;
```

* Concept can be composed in a pretty complicated way
```        
template< class I >
    concept bidirectional_iterator =
        std::forward_iterator<I> &&
        std::derived_from</*ITER_CONCEPT*/<I>, std::bidirectional_iterator_tag> &&
        requires(I i) {
            { --i } -> std::same_as<I&>;
            { i-- } -> std::same_as<I>;
        };
```

## constraint 

 constraint is a sequence of logical operations and operands that specifies requirements on template arguments. They can appear within requires-expressions (see below) and directly as bodies of concepts.
There are three types of constraints:

1) conjunctions
2) disjunctions
3) atomic constraints

The keyword requires is used to introduce a requires-clause, which specifies constraints on template arguments or on a function declaration
template<class T>
void g(T) requires is_purrable<T>(); // error, is_purrable<T>() is not a primary expression
template <class T> void h(T) requires(is_purrable<T>()); // OK

The keyword requires is also used to begin a requires - expression,
which is a prvalue expression of type bool that describes the constraints on
some template arguments.Such an expression is true if the constraints are satisfied,and false otherwise

```
 template <typename T>
    concept Addable = requires(T x) {
  x + x;
}; // requires-expression
```

template <typename T>
requires Addable<T> // requires-clause, not requires-expression
    T add(T a, T b) {
  return a + b;
}

template <typename T>
requires requires(T x) { x + x; } // ad-hoc constraint, note keyword used twice
T add(T a, T b) { return a + b; }

Concepts works really well with lambdas !template <class T>
concept Number = std::is_integer<T>::value;
auto f = [](Number n)

    // infamous `requires requires`. First `requires` is requires-clause,
    // second one is requires-expression. Useful if you don't want to introduce
    // new concept.
    template <typename T>
requires requires(T a, T b) { a + b; }
auto f4(T x)


...............

 For parameter packs, MyConcept... Ts requires MyConcept to be true for each element of the pack, not for the whole pack at once, e.g. requires<T1> && requires<T2> && ... && requires<TLast>.


 ..............
 Contstrains can be used for function overload basically, but one thing is important to note
 
 It’s important to understand how the compiler decomposes constraints and when it can see that they have common atomic constraint and deduce order between them. During decomposition, the concept name is replaced with its definition but requires-expression is not further decomposed. Two atomic constraints are identical only if they are represented by the same expression at the same location. For example, concept C = C1 && C2 is decomposed to conjunction of C1 and C2 but concept C = requires{
  ...
} becomes concept C = Expression-Location-Pair and its body is not further decomposed. If two concepts have common or even the same requirements in their requires-expression, they will always be unordered because either their requires-expressions are not equal or they are equal but at different source locations. The same happens with duplicated usage of a naked type traits - they always represent different atomic constraints because of different locations, thus, cannot be used for orderin

void f(std::integral auto){}        // #1
void f(integral_or_floating auto) {} // #2
void f(std::same_as<char> auto) {}   // #3

// calls #1 because std::integral is more constrained
// than integral_or_floating(#2)
f(int{});

(4) C++ 17 didn’t allow to move rvalue references in return statements,
    function parameters in throw expressions,
    and various forms of conversions unreasonably prevented moving

    (5) std::launder is
    not requried anymore as const andr ref now can be repalced in placement new

    (5) c++ 20 now allows you to do this;
->unofficially called direct aggregate initialization

    struct A {
  int i;
  int b;
};

A a(1, 2) so also you can do vector<A> v;
v.push_back(34, 45)



(6) perfect forwarding and storing callback for later execution is now fully supported in lambas

auto prepare(Func&& func, Args&&... args) {
  auto f = [funcCopy = std::forward<Func>(func),
            ... argCopies = std::forward<Args>(args)]() mutable {
    return funcCopy(argsCopies...);
  };
  return f;
}

(7) it is possible to compile default comparison operator explicitly
    // either member form
    bool
    operator==(foo const &) const = default;
// ... or friend form
friend bool operator==(foo const &, foo const &) = default;


# std::format

std::cout << std::format("Hello {}!\n", "world");