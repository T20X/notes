# reference_wrapper

now can contains incomplete types !

# ranges

[link](./C++20Ranges.md)

# variant

The class template std::variant represents a type-safe union. An instance of std::variant at any given time either holds a value of one of its alternative types, or in the case of error - no value (this state is hard to achieve, see valueless_by_exception).

As with unions, if a variant holds a value of some object type T, the object representation of T is allocated directly within the object representation of the variant itself. Variant is not allowed to allocate additional (dynamic) memory.

A variant is not permitted to hold references, arrays, or the type void. Empty variants are also ill-formed (std::variant<std::monostate> can be used instead).

A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.

Consistent with the behavior of unions during aggregate initialization, a default-constructed variant holds a value of its first alternative, unless that alternative is not default-constructible (in which case the variant is not default-constructible either). The helper class std::monostate can be used to make such variants default-constructible.


std::variant_alternative_t gives type in compile-time based on index

## vs virtual functions / inherentence

it is faster for two reasons:

- the variant version doesn’t use dynamic memory allocation, so all the particles are in the same memory block. CPUs can leverage this to get better performance.
- visitor can be inlined fully! so no need to call a function...

## holds_alternative


template< class T, class... Types >
constexpr bool holds_alternative( const std::variant<Types...>& v ) noexcept;
(since C++17)
Checks if the variant v holds the alternative T. The call is ill-formed if T does not appear exactly once in Types.


## valueless_by_exception

constexpr bool valueless_by_exception() const noexcept;

A variant may become valueless in the following situations:

(guaranteed) an exception is thrown during the initialization of the contained value during move assignment
(optionally) an exception is thrown during the initialization of the contained value during copy assignment
(optionally) an exception is thrown when initializing the contained value during a type-changing assignment
(optionally) an exception is thrown when initializing the contained value during a type-changing emplace
Since variant is never permitted to allocate dynamic memory, previous value cannot be retained in these situations. The situations marked "optionally" can be worked around by implementations that first construct the new value on the stack and then move it into the variant (provided non-throwing move).

This applies even to variants of non-class types:

struct S {
    operator int() { throw 42; }
};

std::variant<float, int> v{12.f}; // OK
v.emplace<1>(S()); // v may be valueless
A variant that is valueless by exception is treated as being in an invalid state: index returns variant_npos, get and visit throw bad_variant_access.

# std::span

The class template span describes an object that can refer to a contiguous sequence of objects with the first element of the sequence at position zero. A span can either have a static extent, in which case the number of elements in the sequence is known at compile-time and encoded in the type, or a dynamic extent. Span is both range and a VIEW!

If a span has dynamic extent, a typical implementation holds two members: a pointer to T and a size. A span with static extent may have only one member: a pointer to T

 std::span has no comparison operators

# concepts

 

(4) C++ 17 didn’t allow to move rvalue references in return statements,
    function parameters in throw expressions,
    and various forms of conversions unreasonably prevented moving

    (5) std::launder is
    not requried anymore as const andr ref now can be repalced in placement new

    (5) c++ 20 now allows you to do this;
->unofficially called direct aggregate initialization

    struct A {
  int i;
  int b;
};

A a(1, 2) so also you can do vector<A> v;
v.push_back(34, 45)



(6) perfect forwarding and storing callback for later execution is now fully supported in lambas

auto prepare(Func&& func, Args&&... args) {
  auto f = [funcCopy = std::forward<Func>(func),
            ... argCopies = std::forward<Args>(args)]() mutable {
    return funcCopy(argsCopies...);
  };
  return f;
}

(7) it is possible to compile default comparison operator explicitly
    // either member form
    bool
    operator==(foo const &) const = default;
// ... or friend form
friend bool operator==(foo const &, foo const &) = default;


# std::format

std::cout << std::format("Hello {}!\n", "world");