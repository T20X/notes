1. operator delete
Weather implementations are using std::free is not specified
   it is unspecified wheather operator delete(void* ptr) or operator delete(void* ptr, size_t sz) is called, BUT ANY OF THEM MAY BE CALLED!
      from standart " f a function without a size parameter is defined, the program should also define the corresponding function with a size parameter. If a function with a size parameter is defined, the program shall also define the corresponding version without the size parameter
      " also "A call to an operator delete with a size parameter may be changed to a call to the corresponding operator delete without a size parameter, without affecting memory allocation"



 - The effect of indirecting through a pointer returned from a request for zero size is undefined
 - A global allocation function is only called as the result of a new expression, or called directly using the function call syntax, or called indirectly to allocate storage for a coroutine state ([dcl.fct.def.coroutine]), or called indirectly through calls to the functions in the C++ standard library.
[Note 2: IMPORTANT ------------- > In particular, a global allocation function is not called to allocate storage for objects with static storage duration, for objects or references with thread storage duration, for objects of type std​::​type_­info, or for an exception object. — end note] <---------------------------

-A deallocation function that is not a class member function shall belong to the global scope and not have a name with internal linkage
-If a deallocation function terminates by throwing an exception, the behavior is undefined. The value of the first argument supplied to a deallocation function may be a null pointer value;
if so , and if the deallocation function is one supplied in the standard library, the call has no effec

*************** allocator ********************

std::allocator<T>::allocate returns T[n] and starts the lifetime of the array but not objects themselves __allocator_base = __gnu_cxx::new_allocator<_Tp>;

std::allocator_traits<std::allocator>::allocate calls std:;
allocator<T>::allocate which in turn would could some form of ::operator new(
    new / ext /
    new_allocator.h does that) 

allocator_traits<std::allocator>::deallocate
calls std::allocator<T>::deallocate
allocator_traits<std::allocator>::construct calls std::construct_at
allocator_traits<std::allocator>::destroy calls std::destroy_at

    **** vector internals *********

gcc using in vector _gnu_cxx::_allocator_traits which is based on
    std::allocator_traits it is using alloc traits from gcc to allocate
    / deallocae its internal storage

    which by default is
    using std::allocator __allocator_base = __gnu_cxx::new_allocator<_Tp>;

6. Since C++ 20 std::allocator requirenments got relaxes.Now,
   it only needs to support - std::allocator::allocate -
   std::allocator::deallocate - std::allocator::value_type -
   std::allocator::size_type - std::allocator::difference_type -


  The rest can be done by std::allocator_traits

7. Why comparions operator is required for allocators ?

    [operator==(a1, a2)] returns true only if the storage allocated by the
        allocator a1 can be deallocated through a2.Establishes reflexive, symmetric,
    and transitive relationship.Does not throw exceptions.

    Although note that still most implemenation also look for is_always_equal member of the allocator in order to determine if the allocator can be reused !Though standart deprecates is_always_equal from C++ 23 in favour of operator==

8.
An implementation is allowed to omit a call to a replaceable global allocation function ([new.delete.single], [new.delete.array]). When it does so, the storage is instead provided by the implementation or provided by extending the allocation of another new-expression.



9.

operator new []
This overhead may be applied in all array new-expressions, including those referencing the library function operator new[](std​::​size_­t, void*) and other placement allocation functions. The amount of overhead may vary from one invocation of new to another.


inline
void*
operator new[](std::size_t n, void* p, std::size_t limit)
{
    if (n <= limit)
        std::cout << "life is good\n";
    else
        throw std::bad_alloc();
    return p;
}

int main()
{
    alignas(std::string) char buffer[100];
    std::string* p = new(buffer, sizeof(buffer)) std::string[3];
}


10. The invocation of the allocation function is sequenced before the evaluations of expressions in the new-initializer. Initialization of the allocated object is sequenced before the value computation of the new-expression.


11. 

using `std::allocator<T>::allocate` works by fiat; the
function is defined to return a pointer, not to the array, but to the
first element of the array

After calling allocate() and before construction of elements, pointer arithmetic of T* is well-defined within the allocated array, but the behavior is undefined if elements are accessed.


12. 

::operator delete does not call destrcutor because type info is lost
::operator [] new is meant to implement special array indexing strategy where allocated size won't be exactly  N * sizeof(T)
bad_alloc can also happen because of heap corruption

