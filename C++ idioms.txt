----------------------
       CRTP 
----------------------
The main idea is to pass Derived class to the base class
it can help in few ways:

No need to override dispatch in every event class! event_crtp gives it for free!
struct state
{
  StatePtr on_event(const event_connecting& e) ...
  StatePtr on_event(const event_connected& e) ...
}
template <State>
struct event 
{
  virtual StatePtr dispatch(state& s) = 0
}

template <class Derived>
class event_crtp : public event<state>
{
  StatePtr dispatch(state& s) override { s.on_event(*static_cast<const Derived*>(this)); }
}

class event_connection : event_crtp<event_connection> {}
class event_connected : event_crtp<event_connected> {}


// BE CAREFULL TO AVOID INFINITE LOOPS IF BASE AND DERIVED FUNCTIINS HAVE THE SAME NAME

template <typename D> class B 
{ 
     public:    
     ...    void f(int i) 
     { static_cast<D*>(this)->f(i); 
     }
};

class D : public B<D> 
{ 
     // no f() here!
};
     ...B<D>* b = ...;b->f(5);                // goes into infinite loop!

-----------
logical XOR
----
!(a) != !(a)

-------
Assignemnt operator
--------
To ensure a strongly exception-safe class that can�t leak any resources when an exception occurs and that can guarantee an operation either is successfully completed or isn�t completed at all, you usually use the copy-and-swap idiom when implementing the assignment operator
------------

------------
Pattern matching
------------
template <typename... Ts> struct overloaded : Ts... 
{ using Ts::operator()...; };
template <typename... Ts> overloaded(Ts...) -> overloaded<Ts...>;

std::visit(overloaded {[&](const normal_scoring& state) {},  
                       [&](const forty_scoring& state) {}},
            m_state );

-----
Swap
---

in modern C++ swap can can give an edge over move swap, as normal swap based of move assignemnt would take 3 moves! 

Normally good libaries in c++ would use swap call

template<class ForwardIt1, class ForwardIt2>
constexpr void iter_swap(ForwardIt1 a, ForwardIt2 b) // constexpr since C++20
{
   using std::swap; // here we bounce back to std::swap call if we cannot perform swap ADL on a and b!
   swap(*a, *b);
}

typical patter
namespace stuff
{
  struct foo { void swap(foo& other); };
  swap(foo& lhs, foo& rhs) { lhs.swap(rhs); }
}

int main()
{
  foo a, b;
  int i = 0;
  int j = 42;

  using std::swap;
  swap(i, j); // calls std::swap
  swap(a, b); // calls stuff::swap(stuff::foo&, stuff::foo&) via ADL
}

-----
runtime concept polymorphism 
------------
tempalte <typename T> void draw(const T& x, ostream out) { out << x << endl; }
template <> void draw(const mytype& x, osteram out) { out << x.to_string() << endl; }

struct package
{
   friend void draw(package& p, ostream) { p._c->draw(); } // defines a non-member friend function!
   struct conceptbase { virtual draw(ostream out) = 0; virtual concept* copy() {} };

   template <typname T> 
   struct model : conceptbase 
   { 
     virtual draw(ostream out) { draw(data_, out); }
     concept* copy() {}
     T data_
    };

   unique_ptr<conceptbase> c_;
}

----
accessing global variables!
----
global variables in header files is good! at least ordering can be enforced, not like with translation units!

inline Informer& str() { static Informer str1{}; return str1; }
static auto& g_str = detail::str();

template <class = void> struct Temp { static Informer other; };
template <> inline Informer Temp<>::other{};
static auto& g_str2 = Temp<>::other;

inline Informer g_str3; //the best! C++17


--------
type erasure (with local buffer optimization)
----
template <typename T>
class smartptr_te_lb {
    struct deleter_base {
        virtual void apply(void*) = 0;
        virtual ~deleter_base() {}
    };
    template <typename Deleter> struct deleter : public deleter_base {
        deleter(Deleter d) : d_(d) {}
        virtual void apply(void* p) { d_(static_cast<T*>(p)); }
        Deleter d_;
    };
    public:
    template <typename Deleter> smartptr_te_lb(T* p, Deleter d) :
        p_(p),
        d_(sizeof(Deleter) > sizeof(buf_) ? new deleter<Deleter>(d) : new (buf_) deleter<Deleter>(d)) 
    {}
    ~smartptr_te_lb() {
        d_->apply(p_);
        if (static_cast<void*>(d_) == static_cast<void*>(buf_)) {
            d_->~deleter_base();
        } else {
            delete d_;
        }
    }
    T* operator->() { return p_; }
    const T* operator->() const { return p_; }
    private:
    T* p_;
    deleter_base* d_;
    char buf_[16];
};