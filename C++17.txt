1.
---------------
STRUCTUREDED BINDINGS
----------------
std::map myMap;    
for (const auto & [k,v] : myMap) 
{ // k - key   // v - value }
}

auto& [ refA, refB, refC, refD ] = myTuple;
auto [a, b] = myPair;

EVENT STRUCTS!
struct S { int x1 : 2; volatile double y1; };
S f();
const auto [ x, y ] = f();

---------------------
2. NEW IF STATEMENT
----------------
if (auto val = GetValue(); condition(val))    
    // on success  
else   
    // on false... 
val is visible only inside the if and else statements, so it doesn't 'leak

----------------
3. INLINE VARIABLES
----------------

-----------
4. THIS BY VALUE
------
This can now be copied instead of using this pointer! Note that class copy 
constructor would be called
  auto f1 = [*this](){}

-----------
5. std::raw_storage_iterator
-------------

----------------
6. pointers
---------------
integer represention of a pointer might not be the same but sequence  as the pointer itself

 it is ok to convert a pointer to integer and then integer back to pointer. But modifying that integer in the middle is kind of on the endge according to c++ standarrt!
---------------

7. Since C++17, the evaluation order of operands of operator << is strictly from left to right, and operands of overloaded operator share the same evaluation order as those of the bulit-in one
  Postfix expressions are evaluated from left to right. This includes functions calls and member
selection expressions.
? Assignment expressions are evaluated from right to left. This includes compound assignments.
? Operands to shift operators are evaluated from left to righ

8. template <auto value> void f() { }

f<10>();               // deduces int