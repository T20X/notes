---------------------------
SFINAE only works in the template context, so the member function itself has to be a template
SFINAE only works if the functions can make it in the overload set!
    for example this won't work
        explicit operator->()
        operator->()
-------------------
the overload resolution is done only on the basis of the function declarationâ€”the parameters, the default arguments, and the return type (the latter is not used to deduce types or select a better overload, but still undergoes type substitution and is covered by SFINAE)
--------------
TEMPLATE SEQUENCE 
------------

------
not deduced contexts
----
 If a template parameter appears in a non-deduced context within a function signature, it can't be deduced from the actual argument

 That said, it's important to understand what "sizeof doesn't evaluate its expression argument" means. It means the expression value isn't calculated, but the expression type is. In your example

sizeof
decltype

(1)  funtion() -> decltype based!

Expression SFINAE
------------------




(2) 




(3) 
template<class _FwdIt,
        class _Ty> inline
        typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type
        _Fill_memset_is_safe(const _FwdIt&, const _Ty&)
    {	// type deduction for _Fill_memset_is_safe_helper
        return {};
    }

trick is that {} will force default construction! but not for void in which case SFINAE kicks in!


-------------
CASES OF SFINAE  ERRORS
-------------
(4)
attempting to use a type that is not a class or enumeration on the left of a scope resolution operator ::
template <class T> int f(typename T::B*);
template <class T> int f(T);
int i = f<int>(0); // uses second overload

(5)
attempting to create an array of void, array of reference, 
array of function, array of negative size, array of non-integral size, or array of size zero.
template <int I> void div(char(*)[I % 2 == 0] = 0) {
    // this overload is selected when I is even
}
template <int I> void div(char(*)[I % 2 == 1] = 0) {
    // this overload is selected when I is odd
}

(6) attempting to create a pointer to reference
(7) attempting to create a reference to void
(8) attempting to create pointer to member of T, where T is not a class type
template<typename T>
class is_class {
    typedef char yes[1];
    typedef char no [2];
    template<typename C> static yes& test(int C::*); // selected if C is a class type
    template<typename C> static no&  test(...);      // selected otherwise
  public:
    static bool const value = sizeof(test<T>(0)) == sizeof(yes);
};

(9)     template <typename Container, 
        typename IterCategory = std::iterator_traits<Container::iterator>::iterator_category, 
       std::enable_if_t<is_same<IterCategory, random_access_iterator_tag>::value, int> = 0>
        void multiEnableIfs(Container& c)
    {
        std::cout << "randon container!" << endl;
    }

    template <typename Container,
        typename IterCategory = std::iterator_traits<Container::iterator>::iterator_category,
        std::enable_if_t<!is_same<IterCategory, random_access_iterator_tag>::value, int> = 0>
        void multiEnableIfs(Container& c)
    {
        std::cout << "NOT randon container!" << endl;
    }

Note that it has to be int>= 0, just default template = void is not going to work because because default template arguments are
 not part of function template's signature, and declaring two different function templates with the same signature is illegal.