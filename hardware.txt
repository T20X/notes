(1) negative integers are represented as two's complemented
first normal ingteger is inverted! then + 1
for example 
1100 -> 0011 -> 0011 + 1 -> 0100

(2) 

This prediction has two aspects: predicting whether a conditional jump will be taken or not, and predicting the target address that a conditional or unconditional jump goes to.

The microarchitecture tries to overcome this problem by feeding the most probable branch into the pipeline and execute it speculatively. Speculative execution means that the instructions are decoded and executed, but the results are not retired into the permanent register file, and memory writes are pending until the branch instruction is finally resolved. If it turns out that the guess was wrong and the wrong branch was executed speculatively, then the pipeline is flushed, the results of the speculative execution are discarded and the other branch is fed into the pipeline. This is called a branch misprediction, and the result is that several clock cycles are wasted. The number of wasted clock cycles is approximately equal to the length of the pipeline.

The time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles.

Some processors allow branch prediction hints to be inserted into the code to tell whether the static prediction should be taken or not taken. The Intel Pentium 4 accepts branch prediction hints, but this feature was abandoned in later Intel processors

(3) Instructions are split into μops
  -  The instruction ADD [MEM1],EAX may generate three μops: one for reading from memory, one for adding, and one for writing the result back to memory
The advantage of this is that the μops can be executed out of order

(4) There are plenty temporary registers CPU can use! We cannot afford the luxury of using a new register for every calculation. But the microprocessor has plenty of temporal registers to use. The microprocessor can rename any of these temporary registers to represent a logical register such as EAX.

(5) Branch Target Buffer (BTB) stores the target address of all jumps. The target address is stored in the BTB the first time an unconditional jump is executed and the first time a conditional jump is taken. The second time the same jump is executed, the target address in the BTB is used for fetching the predicted target into the pipeline, even though the true target is not calculated until the jump reaches the execution stage. The predicted target is very likely to be correct for unconditional jumps, but not certain, because the BTB may not be big enough to contain all jumps in a program, so different jumps may replace each other's entries in the BTB

(6)
first concept to understand is the simplest branch prediction teqnique - saturation count!
it has 4 states:
 - stongly not taken (if set we don't follow branch)
 - weakly not taken (if set we don't follow branch)
 - weakly taken (if set we follow branch)
 - strongly taken (if set we  follow branch)

two level adaptive branch predictor
branch history register - tracks the last N last branch historical info - 0(miss), 1(hit)
Say for N=2, 00 - last two were misses, 01 - miss then hit!
pattern history table - for each value combination that branch history register can have, it would store saturating count state!  There are 2^N items in pattern history table

for pattern 01010101, entries for 00 and 11 are not even used from pattern history table!

Any repetitive pattern with a period of n+1 or less can be predicted perfectly after a warm-up time no longer than three periods. A repetitive pattern with a period p higher than n+1 and less than or equal to 2n can be predicted perfectly if all the p n-bit subsequences are different.
(Example : With n = 4, we can predict the repetitive pattern 000011-000011-000011 with period 6, because the six 4-bit subsequences: 0000, 0001, 0011, 0110, 1100, 1000, are all different.)