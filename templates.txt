--------------
partial/full specializtion for templates must match EXACTLY, otherwise primary template
is used
-------------
The compiler does overload resolution before it even looks at specialisations
------------------------------------------------------------------
for explicit specializations, there is no argument deduction
----------------
4 type of templates
--------------
function templates
class templates
variable templates (since C++14)
alias templates
---------------------------------
can do specialization of a template template member!
-------------------------

template<class T> struct A { // enclosing class template
  template<class T2>
  struct B {}; // primary member template
  template<class T2>
  struct B<T2*> {}; // partial specialization of member template
};
 
template<>
template<class T2>
struct A<short>::B {}; // full specialization of primary member template
                       // (will ignore the partial)
-------------------

---------------------------------
in partial specialization, default arguments cannot appear in the argument list
---------------------------------

------------
conditional
-----------
template<bool B, class T, class F>
struct conditional { typedef T type; };
 
template<class T, class F>
struct conditional<false, T, F> { typedef F type; };


-----------------
SFINAE
------------------

(1) 

template<typename T>
class is_class 
{ 0, ( (void) bar(std::forward<Args>(args)), 0) ... };
  |       |       |                        |     |
  |       |       |                        |     --- pack expand the whole thing 
  |       |       |                        |   
  |       |       --perfect forwarding     --- comma operator
  |       |
  |       -- cast to void to ensure that regardless of bar()'s return type
  |          the built-in comma operator is used rather than an overloaded one
  |
  ---ensure that the array has at least one element so that we don't try to make an
     illegal 0-length array when args is empty

(2)
  template<class _FwdIt,
        class _Ty> inline
        typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type
        _Fill_memset_is_safe(const _FwdIt&, const _Ty&)
    {	// type deduction for _Fill_memset_is_safe_helper
        return {};
    }

trick is that {} will force default construction! but not for void in which case SFINAE kicks in!

----------
declval
----------
returns rvalue ref even for expression which don't have def constructor!
std::remove_reference<decltype(declval<DeclvalStruct>())>::type

--------
eclipsis
--------
// this overload is always in the set of overloads
// ellipsis parameter has the lowest ranking for overload resolution
void test(...)

-----
decay
----
(1) remove reference
(2) if array converts to pointer
(3) if function converts to func pointer
{4} removes const


---
basics
---
no type deduction for class, alias and variable templates
no deduction, and specialization for alias templates
no partial specialization for function templates

---------
class template shortcuts
-----
template <typename T>
struct iterator
{
   iterator& oprerator++(); // here can just use iterator without putting T in here   
}

------------------
variadic functions
-----------------
int sum() { return 0; }
template<typename T, typename... Args>
T sum(T a, Args... args) { return a + sum(args...); }

In C++14 you can also use auto sum(T a, Args... args) in order to get sum of mixed type


-------
std::less
----
template< class T = void >
struct less;
since C++14 for automatic template parameter deduction
template<>
	struct less<void>
	{	// transparent functor for operator<
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const


----
decltype 
---
no deduction inside decltype!
template<typename T> void f(decltype(*std::declval<T>()) arg);
not GONNA WORK!

-----
-------
template <class... T> struct mp_list{};

 template<class A, template<class...> class B>
 using mp_rename = typename mp_rename_impl<A, B>::type;

IF this calls -> mp_rename<mp_list<double, int>, std::pair>
then A = mp_list<double, int>
    B = std::pair

---------
REMEMBER THNIS SPECIAIZATION TEQNICQE
--------
template<class L> struct mp_size_impl;
template<template<class...> class L, class... T> struct mp_size_impl<L<T...>>
{  using type = std::integral_constant<std::size_t, sizeof...(T)>;
template<class L> using mp_size = typename mp_size_impl<L>::type;