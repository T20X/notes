throwing exceptions in constexpr context in compile-time is fine! compiler won't compile it!
-------------------------
types of metaprogramms
-compile-time numeric calcualations
-self-adapting code given input types & constexpr variables
-type manipulations
-type-dependement code
-code generation driven by type collecton
-domain languge specific tools
-----
decltype,sizeof,declval,alingof don't evaluate expression which means sife-effects may not leak if the overload candidates d gets removed by SFINAE!
-----------------------
lambdas can be declared as template variables! but not constexpr until c++20!
template <typename T> auto v = []() { T t1; return 0; };
auto v1 = v<int>();

-------------
lift types to values
template <typename T> struct type {};
constepxr type<T*>{}add_pointer(type<T> v) { {}; }
template <typename T>  constexpr std::true_type is_pointer(type<T*> v) { return {}; }
template <typename T>  constexpr std::false_type is_pointer(type<T> v) { return {}; }

make_tuple(type<int>, type<double>)!
--------------------
easy type configuration!
typedef true_type is_always_equal
------------
Heterogeneous Lookup, C++14. Now comparison can be based on matching pattern
bool operator<(const Product& prod, const std::string_view& sv) { 
    return prod.mName < sv; 
}
bool operator<(const std::string_view& sv, const Product& prod) { 
    return sv < prod.mName; 
}
---------------------------------
struct can be declared inside template parameter itself as incomplete types
template <class T> struct A {}; A<struct t1> t;
----------------------------
the goal is incremental construction of systematic catalogs of useful, efficient and abstract algorithms

-------------
One of the neat tricks you can use is to declare a class template, but not implement it. Whenever you want to check for a specific type, you can try to instantiate that template, and the compiler will report an error specifying exactly which type you passed

template <class T> test;
test<decltype(...)>();

error: invalid use of incomplete type
'class test;std::string&>'


------------
int p = (0,0,2,1);
p=1!!!!!
----------------

class specializations can have parameters like Result(Args...)
template <class Sig, class F> class memoize_helper;
template <class Result, class... Args, class F>
class memoize_helper<Result(Args...), F>
{}

------------
template <typename C,typename T = typename C::value_type>
std::unordered_map<T, unsigned int> 
count_occurrences(const C& collection)
-----
Function template parameters are substituted (replaced by template arguments) twice:
 -explicitly specified template arguments are substituted before template argument deduction
 - deduced arguments and the arguments obtained from the defaults are substituted after template argument deduction

--------------
decltype is explicitly excluded from template argument deduction
-----------------------

 default template argument - typename = std::enable_if_t<std::is_integral<Integer>::value>
     default template arguments are not part of function template's signature
     default template arugments in partial specialization get copied from the primary tempalte if not set!
--------------------------------------
. A substitution failure is any situation when the type or expression above would be ill-formed (with a required diagnostic), *IF WRITTEN* using the substituted argument
--------------------------------------
Only the failures in the types and expressions in the immediate context of the function type or its template parameter types or its explicit specifier (since C++20) are SFINAE errors.

If the evaluation of a substituted type/expression causes a side-effect such as instantiation of some template specialization, generation of an implicitly-defined member function, etc, errors in those side-effects are treated as hard errors. For example subsitutung T in typename T::type to some class A<O> may trigger instantiation of class A<O>, but it may fail...Hence it would be a hard error!

So the mental model I use is that substitution needs to do a "preparation" step first to generate types and members, which might cause hard errors, but once we have all the necessary generation done, any further invalid uses are not errors


--------------------------------------
. decval - Converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors
--------------------------------------
. The compiler does overload resolution before it even looks at specialisations
--------------------------------------
Remeber!
template <template < class...> class A,   class B>
struct test1;
using test1_short = test1<std::tuple <- /*class tempalte*/, std::tuple<int,int,int> /*just class!*/>;

--------------------
For clarity, we will use an explicit return type, but we could use auto. Using an explicit return type has the advantage of generating a compilation error if your type conversions are incorrect.
-----------
The general behavior of the ... operator is to replicate the code fragment on its left for every type in the parameter pack
--------------
partial/full specializtion for templates must match EXACTLY, otherwise primary template
is used
-------------
The compiler does overload resolution before it even looks at specialisations
------------------------------------------------------------------
for explicit specializations, there is no argument deduction
----------------
4 type of templates
--------------
function templates
class templates
variable templates (since C++14)
alias templates
---------------------------------
can do specialization of a template template member!


template<class T> struct A { // enclosing class template
  template<class T2>
  struct B {}; // primary member template
  template<class T2>
  struct B<T2*> {}; // partial specialization of member template
};
 
template<>
template<class T2>
struct A<short>::B {}; // full specialization of primary member template
                       // (will ignore the partial)
-------------------

---------------------------------
in partial specialization, default arguments cannot appear in the argument list
---------------------------------

------------
conditional
-----------
template<bool B, class T, class F>
struct conditional { typedef T type; };
 
template<class T, class F>
struct conditional<false, T, F> { typedef F type; };


-----------------
SFINAE
------------------

(1) 

template<typename T>
class is_class 
{ 0, ( (void) bar(std::forward<Args>(args)), 0) ... };
  |       |       |                        |     |
  |       |       |                        |     --- pack expand the whole thing 
  |       |       |                        |   
  |       |       --perfect forwarding     --- comma operator
  |       |
  |       -- cast to void to ensure that regardless of bar()'s return type
  |          the built-in comma operator is used rather than an overloaded one
  |
  ---ensure that the array has at least one element so that we don't try to make an
     illegal 0-length array when args is empty

(2)
  template<class _FwdIt,
        class _Ty> inline
        typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type
        _Fill_memset_is_safe(const _FwdIt&, const _Ty&)
    {	// type deduction for _Fill_memset_is_safe_helper
        return {};
    }

trick is that {} will force default construction! but not for void in which case SFINAE kicks in!

----------
declval
----------
returns rvalue ref even for expression which don't have def constructor!
std::remove_reference<decltype(declval<DeclvalStruct>())>::type

--------
eclipsis
--------
// this overload is always in the set of overloads
// ellipsis parameter has the lowest ranking for overload resolution
void test(...)

-----
decay
----
(1) remove reference
(2) if array converts to pointer
(3) if function converts to func pointer
{4} removes const


---
basics
---
no type deduction for class, alias and variable templates
no deduction, and specialization for alias templates
no partial specialization for function templates

---------
class template shortcuts
-----
template <typename T>
struct iterator
{
   iterator& oprerator++(); // here can just use iterator without putting T in here   
}

------------------
variadic functions
-----------------
int sum() { return 0; }
template<typename T, typename... Args>
T sum(T a, Args... args) { return a + sum(args...); }

In C++14 you can also use auto sum(T a, Args... args) in order to get sum of mixed type


-------
std::less
----
template< class T = void >
struct less;
since C++14 for automatic template parameter deduction
template<>
	struct less<void>
	{	// transparent functor for operator<
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const


----
decltype 
---
no deduction inside decltype!
template<typename T> void f(decltype(*std::declval<T>()) arg);
not GONNA WORK!

-----
-------
template <class... T> struct mp_list{};

 template<class A, template<class...> class B>
 using mp_rename = typename mp_rename_impl<A, B>::type;

IF this calls -> mp_rename<mp_list<double, int>, std::pair>
then A = mp_list<double, int>
    B = std::pair

---------
REMEMBER THNIS SPECIAIZATION TEQNICQE
--------
template<class L> struct mp_size_impl;
template<template<class...> class L, class... T> struct mp_size_impl<L<T...>>
{  using type = std::integral_constant<std::size_t, sizeof...(T)>;
template<class L> using mp_size = typename mp_size_impl<L>::type;


-------------------
template< bool B, class T, class F >
struct conditional;
(since C++11)
Provides member typedef type, which is defined as T if B is true at compile time, or as F if B is false.

template<class _Ux,
		enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
			_SP_convertible<_Ux, _Ty>>, int> = 0>
		explicit shared_ptr(_Ux * _Px)

template<class... B>
struct conjunction;

	shared_ptr(const shared_ptr& _Other) noexcept
		{	// construct shared_ptr object that owns same resource as _Other
		this->_Copy_construct_from(_Other);
		}

	template<class _Ty2>
		void _Copy_construct_from(const shared_ptr<_Ty2>& _Other)
		{	// implement shared_ptr's (converting) copy ctor
		if (_Other._Rep)
			{

template<class _Ux>
		void _Setp(_Ux * _Px, false_type)
		{	// take ownership of _Px
		_TRY_BEGIN	// allocate control block and set
		_Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ux>(_Px));
		_CATCH_ALL	// allocation failed, delete resource
		delete _Px;
		_RERAISE;

	template<class _Ty0,
		class... _Types>
		friend shared_ptr<_Ty0> make_shared(_Types&&... _Args);


	// FUNCTION TEMPLATE allocate_shared
template<class _Ty,
	class _Alloc,
	class... _Types>
	_NODISCARD inline shared_ptr<_Ty> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args)
	{	// make a shared_ptr
	using _Refoa = _Ref_count_obj_alloc<_Ty, _Alloc>;
	using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Refoa>;
	using _Alref_traits = allocator_traits<_Alref_alloc>;
	_Alref_alloc _Alref(_Al_arg);

	const auto _Rx = _Alref_traits::allocate(_Alref, 1);

	_TRY_BEGIN
		_Alref_traits::construct(_Alref, _Unfancy(_Rx), _Al_arg, _STD forward<_Types>(_Args)...);
	_CATCH_ALL
		_Alref_traits::deallocate(_Alref, _Rx, 1);
	_RERAISE;
	_CATCH_END

	shared_ptr<_Ty> _Ret;
	_Ret._Set_ptr_rep_and_enable_shared(_Rx->_Getptr(), _Unfancy(_Rx));
	return (_Ret);
	}

(1)
template<class _Fn>
	_INLINE_VAR constexpr bool _Pass_functor_by_value_v = sizeof(_Fn) <= sizeof(void *)
		&& conjunction_v<
			is_trivially_copy_constructible<_Fn>,
			is_trivially_destructible<_Fn>>;

template<class _Fn,
	enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0>
	constexpr _Fn _Pass_fn(_Fn _Val)
	{	// pass functor by value
	return (_Val);
	}

template<class _Fn,
	enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0>
	constexpr _Ref_fn<_Fn> _Pass_fn(_Fn& _Val)
	{	// pass functor by "reference"
	return {_Val};
	}

// rolling the array!
template<size_t... _Indices,
	class... _LockN> inline
	void _Lock_from_locks(const int _Target, index_sequence<_Indices...>, _LockN&... _LkN)
	{	// lock _LkN[_Target]
	int _Ignored[] = { ((static_cast<int>(_Indices) == _Target
		? (void)_LkN.lock()
		: void()), 0)... };
	(void)_Ignored;
	}

	// can specialize on function pointer as well!
template <typename F>
struct make_tuple_of_params;
template <typename Ret, typename... Args>
struct make_tuple_of_params<Ret (Args...)>
{ using type = std::tuple<Args...>; };
   // if F is in the form void(double *, double *)
   // make_tuple_of_params is std::tuple<double *, double *>
   make_tuple_of_params_t<F> params;


	 //iterate over tuple! Better then recursion
	 template <typename F, typename Params, std::size_t... I>
auto dispatch_params(F f,
                     Params & params,
                     std::index_sequence<I...>)
{
    return f(std::get<I>(params)...);
}
template <typename F, typename Tuple, std::size_t... I>
void dispatch_to_c(F f, Tuple & t, std::index_sequence<I...>)
{  
	  f(&std::get<I>(t)...);
}


(2)
 template<class T,
         typename std::enable_if<
             !std::is_trivially_destructible<T>{} &&
             (std::is_class<T>{} || std::is_union<T>{}),
            int>::type = 0>
void destroy(T* t)

(3)

    template <typename C, 
        typename = void_t<>> 
        struct is_iterable 
        : std::false_type {}; 

        template <typename C> 
        struct is_iterable< 
        C, void_t<decltype(*begin(std::declval<C>())), 
        decltype(end(std::declval<C>()))>> 
        : std::true_type{};

(4). template <typename T, typename... Args>
std::unique_ptr<T> make_unique_helper(std::false_type, Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

template <typename T, typename... Args>
std::unique_ptr<T> make_unique_helper(std::true_type, Args&&... args) {
   static_assert(std::extent<T>::value == 0,
       "make_unique<T[N]>() is forbidden, please use make_unique<T[]>().");

   typedef typename std::remove_extent<T>::type U;
   return std::unique_ptr<T>(new U[sizeof...(Args)]{std::forward<Args>(args)...});
}

template <typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
   return make_unique_helper<T>(std::is_array<T>(), std::forward<Args>(args)...);
}

(5). 

template<class... _Types> inline
	constexpr tuple<typename _Unrefwrap<_Types>::type...>
		make_tuple(_Types&&... _Args)
	{	// make tuple from elements
	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
	return (_Ttype(_STD forward<_Types>(_Args)...));
	}



(6). 
template <class C, class F>
auto test(C c, F f) -> decltype((void)(c.*f)(), void())
{ std::cout << "Reference overload called\n"; }

template <class C, class F>
auto test(C c, F f) -> decltype((void)((c->*f)()), void())
{ std::cout << "Pointer overload called\n"; }

auto enableIfSINAFE(Container& v) -> decltype(enable_if_t<is_same<Iter, random_access_iterator_tag>::value>(), void())
auto enableIfSINAFE(Container& v) -> decltype(enable_if_t<is_same<Iter, bidirectional_iterator_tag>::value>(), void())

template <class _Ty1>
class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>>
void f()

(7). 
template< class... >
using void_t = void;
(since C++17)
This metafunction is used in template metaprogramming to detect ill-formed types in SFINAE context

// primary template handles types that have no nested ::type member:
template< class, class = std::void_t<> >
struct has_type_member : std::false_type { };
 
// specialization recognizes types that do have a nested ::type member:
template< class T >
struct has_type_member<T, std::void_t<typename T::type>> : std::true_type { };
OR
template< class T >
struct has_type_member<T, std::void_t<decltype(T::member)> : std::true_type { };

(8) Expression tempalate
template<typename T, typename Cont= std::vector<T> >
class MyVector
{
  // assignment operator for MyVector of different type
  template<typename T2, typename R2>
  MyVector& operator=(const MyVector<T2, R2>& other){
    assert(size() == other.size());
    for (std::size_t i = 0; i < cont.size(); ++i) cont[i] = other[i];
    return *this;
  }

template<typename T, typename Op1 , typename Op2>
class MyVectorAdd{
  const Op1& op1;
  const Op2& op2;

public:
  MyVectorAdd(const Op1& a, const Op2& b): op1(a), op2(b){}

  T operator[](const std::size_t i) const{ 
    return op1[i] + op2[i]; 
  }

  std::size_t size() const{ 
    return op1.size(); 
  }
};

// function template for the + operator
template<typename T, typename R1, typename R2>
MyVector<T, MyVectorAdd<T, R1, R2> >
operator+ (const MyVector<T, R1>& a, const MyVector<T, R2>& b){
  return MyVector<T, MyVectorAdd<T, R1, R2> >(MyVectorAdd<T, R1, R2 >(a.data(), b.data()));
}

}

9.  template <class Result, class... Args>
    auto memoFib(Result (*f)(Args...))

10. tuples don't have generic hash functions BUT do have operator <!
11. 
        template <class... InnerArgs>
        Result operator ()(InnerArgs&&... args)
        {
            const auto key = make_tuple(std::forward<InnerArgs>(args)...); #tuple does forwarding inside already!
             ..........
                auto r = _f(*this, std::forward<decay_t<InnerArgs>>(args)...); /but here we need forwarding!
12. function loop!
template <typename... Args>
 void f(Args... args)
{ {o(args)...};


13. this pointer is required!
template<class T>
struct B : A<T> {  int foo() {  return this->i }  };

14.       template<typename _Tp, typename... _Args>
    struct __construct_helper
    {
      template<typename _Alloc2,
        typename = decltype(std::declval<_Alloc2*>()->construct(
          std::declval<_Tp*>(), std::declval<_Args>()...))>
        static true_type __test(int); // declares a function!

      template<typename>
        static false_type __test(...); // declares a function!

      using type = decltype(__test<_Alloc>(0));
    };

      template<typename _Tp, typename... _Args>
    using __has_construct
      = typename __construct_helper<_Tp, _Args...>::type


15.   template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  // three specializations (float, double and 'long double')
  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


16. 

    template <typename... T> struct _and;
    template <> struct _and<> : std::true_type {};
    template <typename T1> struct _and<T1> : T1 {};
    template <typename T1, typename T2> struct _and<T1, T2> : std::conditional<T1::value, T2, T1>::type  {};
    template <typename T1, typename T2, typename... Tn> struct _and<T1, T2, Tn...> : _and<T1, _and<T2, Tn...>> {};

17. 
  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
    static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
           typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
    static true_type
    __test(int);

      template<typename, typename>
    static false_type
    __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };

18.   struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };

      pair&
      operator=(typename conditional<
        __and_<is_copy_assignable<_T1>,
               is_copy_assignable<_T2>>::value,
        const pair&, const __nonesuch&>::type __p)
      {
    first = __p.first;
    second = __p.second;
    return *this;
      }

19.  template <typename T,typename,typename... Args> struct mine_is_constructible : std::false_type {};
     template <typename T, typename... Args> struct mine_is_constructible<T, void_t<decltype(T(std::declval<Args>()...))>, Args...> : std::true_type {};
     template <typename T, typename... Args> using mine_is_constructible_v = mine_is_constructible<T, void_t<T>, Args...>;

20.   template<typename> struct __is_member_function_pointer_helper : public false_type { };
      template<typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public is_function<_Tp>::type { };

21.   template<typename> struct is_function : public false_type { };
      template<typename _Res, typename... _ArgTypes _GLIBCXX_NOEXCEPT_PARM>
    struct is_function<_Res(_ArgTypes...) _GLIBCXX_NOEXCEPT_QUAL>
    : public true_type { };


22. type complete check!
static_assert(sizeof(type), "type must be complete");

23. template <typename T, bool v = is...> struct S {}
    template <typename T> struct S<T, false> {}
     
24.   template<typename _MemberPointer>  struct _Mem_fn; // undefined
  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };

25. Make sure return types are comparable!

   template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;

      template<typename _Func,
           typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>
    struct _Callable : __check_func_return_type<_Res2, _Res> { };

      // Used so the return type convertibility checks aren't done when
      // performing overload resolution for copy construction/assignment.
      template<typename _Tp>
    struct _Callable<function, _Tp> : false_type { }; //note that function here can be a short name for template!

26. template <char ..c>
  constexpr auto operator"" _c() {
//parses char and returns int!
}
1_c + 1_2

27. But since C++11 there is also expression SFINAE. expression SFINAE occurs on arbitrary expressions in the function signature