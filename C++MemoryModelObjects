---------------
Memory model
--------------
The fundamental storage unit in the C++ memory model is the byte
The least significant bit is called the low-order bit; the most significant bit is called the high-order bit. The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every byte has a unique address


There are few terms describing memory model:
- address 
- pointer value 
- integer represetning pointer value - typically type uintptr_t
- memory location

A memory location is either an object of scalar type that is not a bit-field or a maximal sequence of adjacent bit-fields all having nonzero width. It is NOT address as it is more logical concept! Just been a locatoin that complier will allow concurrent access to!

In general, pointer is a type of a variable that stores a link to another object. In C and C++, the link is the address of that object in the program memory. Pointers allow to refer to the same object from multiple locations of the source code without copying the object. Also, the same pointer variable may refer to different objects during its lifetime.


A prvalue of type “pointer to cv T”, where T is an object type, can be converted to a prvalue of type “pointer to cv void”. The pointer value ([basic.compound]) is unchanged by this conversio


- the same pointer may have multiple integer representations
- an array is not pointer-interconvertible with the first element


 C++, a pointer doesnt point to a memory location, it points to a designated object: pointers are high level types, not low level addresses as in assembly. Pointing to an object is not the same to pointing to a different object at the exact same address


 A pointer to void may be converted to or from a pointer to any object type. A pointer to any object type may be converted to a pointer to void and back again; the result shall compare equal to the original pointe
 
 A null pointer constant is an integer literal ([lex.icon]) with value zero or a prvalue of type std​::​nullptr_t. A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type ([basic.compound]) and is distinguishable from every other value of object pointer or function pointer type. Such a conversion is called a null pointer conversion. Two null pointer values of the same type shall compare equal. The conversion of a null pointer constant to a pointer to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion ([conv.qual]). A null pointer constant of integral type can be converted to a prvalue of type std​::​nullptr_t.
[Note 1: The resulting prvalue is not a null pointer value. — end note]



The address of the whole array, and the address of the first element, are defined to be the same, since arrays in C++ (and C) have no intrinsic padding besides that of the constituent objects


As far as C++ is concerned, pointers are not integers; theyre just pointers. You can use casts to convert between pointer values and integer values, and the result should be meaningful in terms of the underlying machines memory model, but not much is guaranteed about the results. You can perform arithmetic on pointers, but on the language level thats not at all the same thing as integer arithmetic (though its probably implemented as scaled integer arithmetic on the machine level).

--------------------------------------------
Every value of pointer type is one of the following:

- a pointer to an object or function (in which case the pointer is said to point to the object or function), or
- a pointer past the end of an object, or
- the null pointer value for that type,
- an invalid pointer value.

conversions to void* and the other way around preserve pointer values

------------------------------

A pointer that points to an object represents the address of the first byte in memory occupied by the object. A pointer past the end of an object represents the address of the first byte in memory after the end of the storage occupied by the object. Even though two objects may have the same address, their value representations may be diffrent, which means that the scalar value representinting pointer value could have diffrent bits even though they point to the same address.


Note that two pointers that represent the same address may nonetheless have different values.

struct C
{
    int x, y;
} c;
 
int* px = &c.x;   // value of px is "pointer to c.x"
int* pxe= px + 1; // value of pxe is "pointer past the end of c.x"
int* py = &c.y;   // value of py is "pointer to c.y"
 
assert(pxe == py); // == tests if two pointers represent the same address
                   // may or may not fire


An lvalue or rvalue of type “array of N T” or “array of unknown bound of T” can be converted to an rvalue of type “pointer to T.”

Another example is array. The first member of array may have diffrent pointer value compared to the pointer to array. Generally pointer-interconvertible define if pointer values are the same.

int a[4] = {1, 2, 3, 4};
void* p1 = a;
void* p2 = &a[0];

assert((int*)p1 == (int*)p2 ) // MAY FAIL!


An object of array type contains a contiguously allocated non-empty set of N subobjects of type T

Pointers of every type have a special value known as null pointer value of that type. A pointer whose value is null does not point to an object or a function (the behavior of dereferencing a null pointer is undefined), and compares equal to all pointers of the same type whose value is also null

Pointer to object of any type can be implicitly converted to pointer to void (optionally cv-qualified); the pointer value is unchanged. The reverse conversion, which requires static_cast or explicit cast, yields the original pointer value

there are no pointers to references and there are no pointers to bit-fields
standard does not require that pointers are directly related to memory addresses




A null pointer constant is an integer literal ([lex.icon]) with value zero or a prvalue of type std​::​nullptr_t. A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type ([basic.compound]) and is distinguishable from every other value of object pointer or function pointer type. Such a conversion is called a null pointer conversion. Two null pointer values of the same type shall compare equal. The conversion of a null pointer constant to a pointer to cv-qualified type is a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion ([conv.qual]). A null pointer constant of integral type can be converted to a prvalue of type std​::​nullptr_t

(new in c++11)
{
  A memory location is either an object of scalar type that is not a bit-field or a maximal sequence of adjacent bit-fields all having nonzero width.
  [Note 2: Various features of the language, such as references and virtual functions, might involve additional memory locations that are not accessible to programs but are managed by the implementation. — end note]


  Two or more threads of execution can access separate memory locations without interfering with each other.
  4
  #
  [Note 3: Thus a bit-field and an adjacent non-bit-field are in separate memory locations, and therefore can be concurrently updated by two threads of execution without interference. The same applies to two bit-fields, if one is declared inside a nested struct declaration and the other is not, or if the two are separated by a zero-length bit-field declaration, or if they are separated by a non-bit-field declaration. It is not safe to concurrently update two bit-fields in the same struct if all fields between them are also bit-fields of nonzero width. — end note]
}

-------
Object model
-------

The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. An object is created by a definition, by a new-expression ([expr.new]), by an operation that implicitly creates objects (see below), when implicitly changing the active member of a union, or when a temporary object is created ([conv.rval], [class.temporary]). An object occupies a region of storage in its period of construction ([class.cdtor]), throughout its lifetime, and in its period of destruction ([class.cdtor]).
[Note 1: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. — end note]
The properties of an object are determined when the object is created. 
- An object can have a name ([basic.pre]).
- An object has a storage duration ([basic.stc]) which influences its lifetime ([basic.life]). 
- An object has a type ([basic.types]).
[Note 2: Some objects are polymorphic ([class.virtual]); the implementation generates information associated with each such object that makes it possible to determine that objects type during program execution. — end note]
The lifetime of an object o of type T ends when:
if T is a class type with a non-trivial destructor ([class.dtor]), the destructor call starts, OR the storage which the object occupies is released, or is reused by an object that is not nested within o




Objects can contain other objects, called subobjects. A subobject can be a member subobject ([class.mem]), a base class subobject ([class.derived]), or an array element. An object that is not a subobject of any other object is called a complete object. If an object is created in storage associated with a member subobject or array element e (which may or may not be within its lifetime), the created object is a subobject of e containing object if:
(2.1) the lifetime of e containing object has begun and not ended, and
(2.2) the storage for the new object exactly overlays the storage location associated with e, and
(2.3) the new object is of the same type as e (ignoring cv-qualification).
------->IMPORTANT<---- NOTE THAT IT DOES NOT LIST BASE CLASS SUBOBJECT ABOVE, REPLACING WHICH WOULD END THE LIFETIME OF THE CONTAINING OBJECT <-----> 

<----->IMPORTANT <----->
 I interpret it to say that the subobject property is determined at creation by the listed rules, not that at any given point in time the subobject property is determined according to the listed rules



struct A {
    T t /*initializer*/;
    U* u;

    A() {
        t.~T(); 
        u = ::new(static_cast<void*>(&t)) U /*initializer*/; 
      //u does not point to suboject because lifetime of A has not started yet!
    }
3
#
If a complete object is created ([expr.new]) in storage associated with another object e of type “array of N unsigned char” or of type “array of N std​::​byte” ([cstddef.syn]), that array provides storage for the created object if:
(3.1) the lifetime of e has begun and not ended, and
(3.2) the storage for the new object fits entirely within e, and
(3.3) there is no array object that satisfies these constraints nested within e.
[Note 3: If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused ([basic.life]). — end note]


An object of trivially copyable or standard-layout type ([basic.types.general]) shall occupy contiguous bytes of storage

Unless an object is a bit-field or a subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects with overlapping lifetimes that are not bit-fields may have the same address if one is nested within the other, or if at least one is a subobject of zero size and they are of different types; otherwise, they have distinct addresses and occupy disjoint bytes of storage.22
[Example 2:
static const char test1 = 'x';
static const char test2 = 'x';
const bool b = &test1 != &test2; 

!IMPORTANT: BUT NOTE THAT -------->

If a standard-layout class object has any non-static data members, its address is the same as the address of its first non-static data member if that member is not a bit-field. Its address is also the same as the address of each of its base class subobjects.
[Note 11: There can therefore be unnamed padding within a standard-layout struct object inserted by an implementation, but not at its beginning, as necessary to achieve appropriate alignment. — end note]

---
type
---

Objects, references, functions including function template specializations, and expressions have a property called type, which both restricts the operations that are permitted for those entities and provides semantic meaning to the otherwise generic sequences of bits.


-------------
Lifetime
------------

(1) #
The lifetime of an object or reference is a runtime property of the object or reference. A variable is said to have vacuous initialization if it is default-initialized and, if it is of class type or a (possibly multidimensional) array thereof, that class type has a trivial default constructor. The lifetime of an object of type T begins when:
(1.1)
storage with the proper alignment and size for type T is obtained, and
(1.2)
its initialization (if any) is complete (including vacuous initialization) ([dcl.init]),
except that if the object is a union member or subobject thereof, its lifetime only begins if that union member is the initialized member in the union ([dcl.init.aggr], [class.base.init]), or as described in [class.union], [class.copy.ctor], and [class.copy.assign], and except as described in [allocator.members]. The lifetime of an object o of type T ends when:
(1.3) if T is a non-class type, the object is destroyed, or
(1.4) if T is a class type, the destructor call starts, or
(1.5) the storage which the object occupies is released, or is reused by an object that is not nested within o ([intro.object]).

(2) The lifetime of a reference begins when its initialization is complete. The lifetime of a reference ends as if it were a scalar object requiring storage.
[Note 1: [class.base.init] describes the lifetime of base and member subobjects. 


(3) The lifetime of an object o of type T ends when:
- if T is a class type with a non-trivial destructor ([class.dtor]), the destructor call starts,
- if T is a class type, the destructor call starts, or
- the storage which the object occupies is released, or is reused by an object that is not nested within o ([intro.object]).


Right now, even if you called n.~int();, that would not actually end ns lifetime


 you cannot create an array from allocating two objects adjacently to each othe



(5) This removed in C++20 -----> If the subobject contains a reference member or a const subobject, the name of the original subobject cannot be used to access the new object ([basic.life]). ?�?end note?] [?Example:

struct X { const int n; };
union U { X x; float f; };
void tong() {
  U u = {{ 1 }};
  u.f = 5.f;                          // OK, creates new subobject of u ([class.union])
  X *p = new (&u.x) X {2};            // OK, creates new subobject of u
  assert(p->n == 2);                  // OK
  assert(*std::launder(&u.x.n) == 2); // OK
  assert(u.x.n == 2);                 // undefined behavior, u.x does not name new subobject
}


(6) It is not strictly defined in the C++ standard, what is a lifetime. Intuitively we refer to it as a time when object lives. The reason for introducing the concept (not confuse with concepts feature) of a lifetime in the language is to know when we can use objects without some limitations.

The actual life of an object has multiple stages:

storage allocated, constructor not yet started
object under construction (constructor is running)
lifetime


 
object under destruction (destructor is running)
destructor finished, storage not yet released



(7) When an object is being constructed and destructed, we can do a little bit more with the object. Namely, we can get to the members of object under construction, that already were initialized. An important thing to note is, that we can do that only via this pointer. Let’s look at what it means by looking at the example from the draft:

struct C;
void no_opt(C*);
struct C {
  int c;
  C() : c(0) { no_opt(this); }
};
const C cobj;
void no_opt(C* cptr) {
  int i = cobj.c * 100;         // value of cobj.c is unspecified
  cptr->c = 1;
  cout << cobj.c * 100          // value of cobj.c is unspecified
       << '\n';
}
in this example inside no_opt using object cobj by its name and not by its pointer reads unspecified values.


(8) Before the lifetime of an object has started but after the storage which the object will occupy has been allocated23 or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that represents the address of the storage location where the object will be or was located may be used but only in limited ways. ------------------------> SUPER IMPORTANT(this means that during construciton and destruction the lifetime by standart has not started yet and not finished correspondinly ) For an object under construction or destruction, see [class.cdtor] <-----------------. Otherwise, such a pointer refers to allocated storage ([basic.stc.dynamic.allocation]), and using the pointer as if the pointer were of type void* is well-defined. Indirection through such a pointer is permitted but the resulting lvalue may only be used in limited ways, as described below. The program has undefined behavior if:
(6.1) the pointer is used as the operand of a delete-expression,
(6.2) the pointer is used to access a non-static data member or call a non-static member function of the object, or
(6.3) the pointer is implicitly converted ([conv.ptr]) to a pointer to a virtual base class, or
(6.4) the pointer is used as the operand of a static_cast ([expr.static.cast]), except when the conversion is to pointer to cv void, or to pointer to cv void and subsequently to pointer to cv char, cv unsigned char, or cv std​::​byte ([cstddef.syn]), or
(6.5) the pointer is used as the operand of a dynamic_cast ([expr.dynamic.cast]).

(9) If a program ends the lifetime of an object of type T with static ([basic.stc.static]), thread ([basic.stc.thread]), or automatic ([basic.stc.auto]) storage duration and if T has a non-trivial destructor,24 and another object of the original type does not occupy that same storage location when the implicit destructor call takes place, the behavior of the program is undefined. This is true even if the block is exited with an exception.
[Example 3:
class T { };
struct B {
   ~B();
};

void h() {
   B b;
   new (&b) T;
} 

(10) Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects a and b with overlapping lifetimes that are not bit-fields may have the same address if one is nested within the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they have distinct addresses.5

[?Example:

static const char test1 = 'x';
static const char test2 = 'x';
const bool b = &test1 != &test2;      // always true


Before the lifetime of an object has started but after the storage which the object will occupy has been allocated23 or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that represents the address of the storage location where the object will be or was located may be used but only in limited ways. For an object under construction or destruction, see [class.cdtor]. Otherwise, such a pointer refers to allocated storage ([basic.stc.dynamic.allocation]), and using the pointer as if the pointer were of type void* is well-defined. Indirection through such a pointer is permitted but the resulting lvalue may only be used in limited ways, as described below

struct B { vritual f();}; //non trivial defualt constructor because of virtual table pointer
struct D1 : B { void f(); };
struct D2 : B { void f(); };
void B::mutate() {
  new (this) D2;    // reuses storage � ends the lifetime of *this
  f();  //not ok, object stroage was reused by another *type*(D2)!
    However this is well defined! (new (this) D2)->f() 
}
B* b = new D1;

If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if the original object is transparently replaceable (see below) by the new object. An object is transparently replaceable by an object 

(8.1) the storage that occupies exactly overlays the storage that 
 occupied, and
(8.2) are of the same type (ignoring the top-level cv-qualifiers), and
(8.3) is not a const, complete object, and
(8.4) neither is a potentially-overlapping subobject ([intro.object]), and
(8.5) either  both complete objects, or  are direct subobjects of objects p1
 and p2 , respectively, and p1 is transparently replaceable by p2 .

[Example 2:
struct C {
  int i;
  void f();
  const C& operator=( const C& );
};

const C& C::operator=( const C& other) {
  if ( this != &other ) {
    this->~C();                 // lifetime of *this ends
    new (this) C(other);        // new object of type C created
    f();                        // well-defined
  }
  return *this;
}


(11) For an object with a non-trivial constructor, referring to any non-static member or base class of the object before the constructor begins execution results in undefined behavior. For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor finishes execution results in undefined behavio
struct W { int j; };
struct X : public virtual W { };
struct Y {
  int* p;
  X x;
  Y() /*******constructor execution begins*****/: p(&x.j) {   // undefined, x is not yet constructed
    
(12) Objects can contain other objects, called subobjects. A subobject can be a member subobject ([class.mem]), a base class subobject ([class.derived]), or an array element. An object that is not a subobject of any other object is called a complete object. If an object is created in storage associated with a member subobject or array element e (which may or may not be within its lifetime), the created object is a subobject of e's containing object if:
(2.1) the lifetime of e's containing object has begun and not ended, and
(2.2) the storage for the new object exactly overlays the storage location associated with e, and
(2.3) the new object is of the same type as e (ignoring cv-qualification).


--- IMPORTANT > STANDART PRETTY CLEARLY defines what subobject is really, it is either member subobject in a class , base base or an array element. Everything else we dont consider subobjects. Note that complete object is an object which is not suboject!


 If a complete object is created ([expr.new]) in storage associated with another object e of type “array of N unsigned char” or of type “array of N std​::​byte” ([cstddef.syn]), that array **********PROVIDES STORAGE******** for the created object if:
(3.1) the lifetime of e has begun and not ended, and
(3.2) the storage for the new object fits entirely within e, and
(3.3) there is no array object that satisfies these constraints nested within e. ---->  struct A { unsigned char a[32]; }; ...
----> .... struct B { unsigned char b[16]; };

[Note 3: If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused ([basic.life]). — end note]
[Example 1:
template<typename ...T>
struct AlignedUnion {
  alignas(T...) unsigned char data[max(sizeof(T)...)];
};
int f() {
  AlignedUnion<int, char> au;
  int *p = new (au.data) int;           // OK, au.data provides storage
  char *c = new (au.data) char();       // OK, ends lifetime of *p because of "
  [Note 3: If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused ([basic.life]). — end note]"
  char *d = new (au.data + 1) char();
  return *c + *d;                       // OK
}

struct A { unsigned char a[32]; };
struct B { unsigned char b[16]; };
A a;
B *b = new (a.a + 8) B;                 // a.a provides storage for *b
int *p = new (b->b + 4) int;            // b->b provides storage for *p
                                        // a.a does not provide storage for *p (directly),
                                        // but *p is nested within a (see below)
— end example]

 An object a is nested within another object b if:
(4.1) a is a subobject of b, or
(4.2) b provides storage for a(IMPORTANT ---> note that only arrays of unsigned char / std::byte CANNNNNN provide storage), or
(4.3) there exists an object c where a is nested within c, and c is nested within b.



(13)
Block-scope variables not explicitly declared static, thread_­local, or extern have automatic storage duration. The storage for these entities lasts until the block in which they are created exits.
 # [ Note: These variables are initialized and destroyed as described in [stmt.dcl].  — end note ]

#
If a variable with automatic storage duration has initialization or a destructor with side effects, an implementation shall not destroy it before the end of its block nor eliminate it as an optimization, even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified in [class.copy].


Variables with automatic storage duration are initialized each time their declaration-statement is executed. Variables with automatic storage duration declared in the block are destroyed on exit from the block.  On exit from a scope (however accomplished), objects with automatic storage duration that have been constructed in that scope are destroyed in the reverse order of their construction

Notice that the order of destruction is specified, but the order of automatic storage release is not specified. This means that the implementation could release the storage right after each variable is destroyed, or release it all at once later, or in some arbitrary other order.

Now, the fact that it uses the singular for storage ("the storage for ... lasts") rather than talking about each variable individually may suggest that the intent is for the storage as a whole to be released at once for that scope. But there is no explicit statement of this in the standard. So as long as a variable is destroyed before its storage is released, any ordering of destruction vs. release appears to be legal, BUT STANDART DID AGREE in 2015 that RELEASE MUST HAPPEN AFTER DESTRUCTION! CWG Issue 2115

 --EXISTING C++ ISUE (CWG 2115) --------->
Basically it is not established wheather destructors for automatic variables at the end of block or memory (trivial types) for them is going to be released first. Because trivally destructible types don't need destructor to be run
--------------
The relative ordering between destruction of automatic variables on exit from a block and the release of the variables' storage is not specified by the Standard: are all the destructors executed first and then the storage released, or are they interleaved?

Notes from the February, 2016 meeting:

CWG agreed that the storage should persist until all destructions are complete, although the “as-if” rule would allow for unobservable optimizations of this ordering.
<-----------------


This means it is entirely possible for the code to work, for n to outlive a. But it is unspecified whether it does work.

(14)

In [basic.indet]/1, we have:

When storage for an object with automatic or dynamic storage duration is obtained, the object has an indeterminate value, and if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced ([expr.ass]).

One important detail here (which I missed at first) is that <obtaining storage> is different from <allocating storage> or the storage duration of a storage region. The <obtain storage> words are also used to define the beginning of an objects lifetime in [basic.life]/1 and in the context of a new-expression in [expr.new]/10:

A new-expression may obtain storage for the object by calling an allocation function ([basic.stc.dynamic.allocation]). ... [ Note: ... The set of allocation and deallocation functions that may be called by a new-expression may include functions that do not perform allocation or deallocation; for example, see [new.delete.placement]. — end note ]


(15)
dynamic storage duration means that you have to take care for the object lifecycle and delete when necessary
dynamic storage means that there are no constraints to the storage duration.


(16)
[no_unique_address]
Indicates that this data member need not have an address distinct from all other non-static data members of its class. This means that if the member has an empty type (e.g. stateless Allocator), the compiler may optimise it to occupy no space, just like if it were an empty base. If the member is not empty, any tail padding in it may be also reused to store other data members.


(17)
at least one of the following must be true for any two objects:

They must have different types.
They must have different addresses in memory.
They must actually be the same object.

------
implicitly created objects
-------

-----> it is either aggregate or got trival eglibible constructor  and a trivial non-deleted destructor. Note that in aggregatre if subojbect is not itself implicitly created object than it won't be created. <---------------


Certain operations may implicitly create and start the lifetime of objects of implicit-lifetime types, if doing so would prevent undefined behavior. However, such operations do not start the lifetimes of subobjects of such objects that are not themselves of implicit-lifetime types.

The following operations may implicitly create objects:

An operation that begins the lifetime of an array of unsigned char or std::byte (since C++17).
An invocation of std::aligned_alloc, (since C++17)std::calloc, std::malloc, or std::realloc.
Any implicit or explicit invocation of a function named operator new or operator new[] (including non-allocating and user-defined placement allocation functions). Including
std::allocator::allocate
std::allocator::allocate_at_least (since C++23)
(since C++17) An invocation of std::memory_resource::allocate, regardless of how storage is obtained. Including
std::pmr::polymorphic_allocator::allocate (since C++17)
std::pmr::polymorphic_allocator::allocate_bytes (since C++20)
std::pmr::polymorphic_allocator::allocate_object (since C++20)
An invocation of std::memcpy or std::memmove.
(since C++20) An invocation of std::bit_cast.
(since C++23) An invocation of std::start_lifetime_as or std::start_lifetime_as_array.
An assignment expression that involves union members if the unions assignment operator is built-in or trivial.


***********
Compound types
***********

Compound types can be constructed in the following ways:

(1.1) arrays of objects of a given type, [dcl.array];
(1.2) functions, which have parameters of given types and return void or references or objects of a given type, [dcl.fct];
(1.3) pointers to cv void or objects or functions (including static members of classes) of a given type, [dcl.ptr];
(1.4) references to objects or functions of a given type, [dcl.ref]. There are two types of references:
(1.4.1) lvalue reference
(1.4.2) rvalue reference

(1.5)
classes containing a sequence of objects of various types (Clause [class]), a set of types, enumerations and functions for manipulating these objects ([class.mfct]), and a set of restrictions on the access to these entities (Clause [class.access]);

(1.6)
unions, which are classes capable of containing objects of different types at different times, [class.union];

(1.7)
enumerations, which comprise a set of named constant values. Each distinct enumeration constitutes a different enumerated type, [dcl.enum];


---------------

An aggregate is one of the following types:

array type
class type (typically, struct or union), that has
no private or protected direct (since C++17
no user-provided, inherited, or explicit constructors (explicitly defaulted or deleted constructors are allowed)
no virtual, private, or protected (since C++17) base classes
no virtual member functions

--------------
A literal type is one whose layout can be determined at compile time. The following are the literal types:

void
scalar types
references
Arrays of void, scalar types or references
A class that has a constexpr destructor, and one or more constexpr constructors that are not move or copy constructors. Additionally, all its non-static data members and base classes must be literal types and not volatile.


Specifies that a type is a literal type. Literal types are the types of constexpr variables and they can be constructed, manipulated, and returned from constexmemset pr functions.




------------
copying
---
memset  will set padding bits to 0
