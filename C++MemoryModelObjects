---------------
Memory model
--------------
The fundamental storage unit in the C++ memory model is the byte
The least significant bit is called the low-order bit; the most significant bit is called the high-order bit. The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every byte has a unique address

A memory location is either an object of scalar type that is not a bit-field or a maximal sequence of adjacent bit-fields all having nonzero width


-------
Object model
-------

The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. An object is created by a definition, by a new-expression ([expr.new]), by an operation that implicitly creates objects (see below), when implicitly changing the active member of a union, or when a temporary object is created ([conv.rval], [class.temporary]). An object occupies a region of storage in its period of construction ([class.cdtor]), throughout its lifetime, and in its period of destruction ([class.cdtor]).
[Note 1: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. — end note]
The properties of an object are determined when the object is created. An object can have a name ([basic.pre]). An object has a storage duration ([basic.stc]) which influences its lifetime ([basic.life]). An object has a type ([basic.types]).
[Note 2: Some objects are polymorphic ([class.virtual]); the implementation generates information associated with each such object that makes it possible to determine that object's type during program execution. — end note]
The lifetime of an object o of type T ends when:
if T is a class type with a non-trivial destructor ([class.dtor]), the destructor call starts, OR the storage which the object occupies is released, or is reused by an object that is not nested within o



Objects can contain other objects, called subobjects. A subobject can be a member subobject ([class.mem]), a base class subobject ([class.derived]), or an array element. An object that is not a subobject of any other object is called a complete object. If an object is created in storage associated with a member subobject or array element e (which may or may not be within its lifetime), the created object is a subobject of e's containing object if:
(2.1)
the lifetime of e's containing object has begun and not ended, and
(2.2)
the storage for the new object exactly overlays the storage location associated with e, and
(2.3)
the new object is of the same type as e (ignoring cv-qualification).
3
#
If a complete object is created ([expr.new]) in storage associated with another object e of type “array of N unsigned char” or of type “array of N std​::​byte” ([cstddef.syn]), that array provides storage for the created object if:
(3.1)
the lifetime of e has begun and not ended, and
(3.2)
the storage for the new object fits entirely within e, and
(3.3)
there is no array object that satisfies these constraints nested within e.
[Note 3: If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused ([basic.life]). — end note]




An object of trivially copyable or standard-layout type ([basic.types.general]) shall occupy contiguous bytes of storage




Some operations are described as implicitly creating objects within a specified region of storage. For each operation that is specified as implicitly creating objects, that operation implicitly creates and starts the lifetime of zero or more objects of implicit-lifetime types ([basic.types.general]) in its specified region of storage if doing so would result in the program having defined behavior. If no such set of objects would give the program defined behavior, the behavior of the program is undefined. If multiple such sets of objects would give the program defined behavior, it is unspecified which such set of objects is created.
[Note 4: Such operations do not start the lifetimes of subobjects of such objects that are not themselves of implicit-lifetime types. — end note]
11
#
Further, after implicitly creating objects within a specified region of storage, some operations are described as producing a pointer to a suitable created object. These operations select one of the implicitly-created objects whose address is the address of the start of the region of storage, and produce a pointer value that points to that object, if that value would result in the program having defined behavior. If no such pointer value would give the program defined behavior, the behavior of the program is undefined. If multiple such pointer values would give the program defined behavior, it is unspecified which such pointer value is produced.
12
#
[Example 3:
#include <cstdlib>
struct X { int a, b; };
X *make_x() {
  // The call to std​::​malloc implicitly creates an object of type X
  // and its subobjects a and b, and returns a pointer to that X object
  // (or an object that is pointer-interconvertible ([basic.compound]) with it),
  // in order to give the subsequent class member access operations
  // defined behavior.
  X *p = (X*)std::malloc(sizeof(struct X));
  p->a = 1;
  p->b = 2;
  return p;
}


-------------
Lifetime
------------

1
#
The lifetime of an object or reference is a runtime property of the object or reference. A variable is said to have vacuous initialization if it is default-initialized and, if it is of class type or a (possibly multidimensional) array thereof, that class type has a trivial default constructor. The lifetime of an object of type T begins when:
(1.1)
storage with the proper alignment and size for type T is obtained, and
(1.2)
its initialization (if any) is complete (including vacuous initialization) ([dcl.init]),
except that if the object is a union member or subobject thereof, its lifetime only begins if that union member is the initialized member in the union ([dcl.init.aggr], [class.base.init]), or as described in [class.union], [class.copy.ctor], and [class.copy.assign], and except as described in [allocator.members]. The lifetime of an object o of type T ends when:
(1.3)
if T is a non-class type, the object is destroyed, or
(1.4)
if T is a class type, the destructor call starts, or
(1.5)
the storage which the object occupies is released, or is reused by an object that is not nested within o ([intro.object]).
2
#
The lifetime of a reference begins when its initialization is complete. The lifetime of a reference ends as if it were a scalar object requiring storage.
3
#
[Note 1: [class.base.init] describes the lifetime of base and member subobjects. 


Lifetime of a reference is exactly its storage duration

The lifetime of an object o of type T ends when:
if T is a class type with a non-trivial destructor ([class.dtor]), the destructor call starts, OR the storage which the object occupies is released, or is reused by an object that is not nested within o

If the subobject contains a reference member or a const subobject, the name of the original subobject cannot be used to access the new object ([basic.life]). ?�?end note?] [?Example:

struct X { const int n; };
union U { X x; float f; };
void tong() {
  U u = {{ 1 }};
  u.f = 5.f;                          // OK, creates new subobject of u ([class.union])
  X *p = new (&u.x) X {2};            // OK, creates new subobject of u
  assert(p->n == 2);                  // OK
  assert(*std::launder(&u.x.n) == 2); // OK
  assert(u.x.n == 2);                 // undefined behavior, u.x does not name new subobject
}

If an object is recreated at the same memory location (e.g. by placement new), the glvalue becomes valid once again, if all of the following is true:

1) the storage occupied by the new object exactly overlays the storage occupied by the old object
2) the new object has the same type as the old object, ignoring top-level cv-qualifiers
3) the original object's type was not const-qualified
4) the original object was not a class with const or reference non-static data members
5) both the original and the new objects are the most-derived objects of their type



It is not strictly defined in the C++ standard, what is a lifetime. Intuitively we refer to it as a time when object lives. The reason for introducing the concept (not confuse with concepts feature) of a lifetime in the language is to know when we can use objects without some limitations.

The actual life of an object has multiple stages:

storage allocated, constructor not yet started
object under construction (constructor is running)
lifetime
object under destruction (destructor is running)
destructor finished, storage not yet released

Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects a and b with overlapping lifetimes that are not bit-fields may have the same address if one is nested within the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they have distinct addresses.5

[?Example:

static const char test1 = 'x';
static const char test2 = 'x';
const bool b = &test1 != &test2;      // always true


struct B { vritual f();}; //non trivial defualt constructor because of virtual table pointer
struct D1 : B { void f(); };
struct D2 : B { void f(); };
void B::mutate() {
  new (this) D2;    // reuses storage � ends the lifetime of *this
  f();  //not ok, object stroage was reused by another *type*(D2)!
    However this is well defined! (new (this) D2)->f() 
}
B* b = new D1;

struct C {f(); mutate()};
void C::mutate() {
  new (this) C;    // reuses storage � ends the lifetime of *this
  f();  // ok, object stroage is of the same class!
}

If a program ends the lifetime of an object of type T with static, thread, or automatic storage duration and if T has a non-trivial destructor,42 the program must ensure that an object of the original type occupies that same storage location when the implicit destructor call takes place; otherwise the behavior of the program is undefined.

For an object with a non-trivial constructor, referring to any non-static member or base class of the object before the constructor begins execution results in undefined behavior. For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor finishes execution results in undefined behavio
struct W { int j; };
struct X : public virtual W { };
struct Y {
  int* p;
  X x;
  Y() /*******constructor execution begins*****/: p(&x.j) {   // undefined, x is not yet constructed
    
------
implicitly created objects
-------

-----> it is either aggregate or got trival eglibible constructor  and a trivial non-deleted destructor. Note that in aggregatre if subojbect is not itself implicitly created object than it won't be created. <---------------


Certain operations may implicitly create and start the lifetime of objects of implicit-lifetime types, if doing so would prevent undefined behavior. However, such operations do not start the lifetimes of subobjects of such objects that are not themselves of implicit-lifetime types.

The following operations may implicitly create objects:

An operation that begins the lifetime of an array of unsigned char or std::byte (since C++17).
An invocation of std::aligned_alloc, (since C++17)std::calloc, std::malloc, or std::realloc.
Any implicit or explicit invocation of a function named operator new or operator new[] (including non-allocating and user-defined placement allocation functions). Including
std::allocator::allocate
std::allocator::allocate_at_least (since C++23)
(since C++17) An invocation of std::memory_resource::allocate, regardless of how storage is obtained. Including
std::pmr::polymorphic_allocator::allocate (since C++17)
std::pmr::polymorphic_allocator::allocate_bytes (since C++20)
std::pmr::polymorphic_allocator::allocate_object (since C++20)
An invocation of std::memcpy or std::memmove.
(since C++20) An invocation of std::bit_cast.
(since C++23) An invocation of std::start_lifetime_as or std::start_lifetime_as_array.
An assignment expression that involves union members if the union's assignment operator is built-in or trivial.


***********
Compound types
***********

Compound types can be constructed in the following ways:

(1.1)
arrays of objects of a given type, [dcl.array];

(1.2)
functions, which have parameters of given types and return void or references or objects of a given type, [dcl.fct];

(1.3)
pointers to cv void or objects or functions (including static members of classes) of a given type, [dcl.ptr];

(1.4)
references to objects or functions of a given type, [dcl.ref]. There are two types of references:

(1.4.1)
lvalue reference

(1.4.2)
rvalue reference

(1.5)
classes containing a sequence of objects of various types (Clause [class]), a set of types, enumerations and functions for manipulating these objects ([class.mfct]), and a set of restrictions on the access to these entities (Clause [class.access]);

(1.6)
unions, which are classes capable of containing objects of different types at different times, [class.union];

(1.7)
enumerations, which comprise a set of named constant values. Each distinct enumeration constitutes a different enumerated type, [dcl.enum];


---------------

An aggregate is one of the following types:

array type
class type (typically, struct or union), that has
no private or protected direct (since C++17
no user-provided, inherited, or explicit constructors (explicitly defaulted or deleted constructors are allowed)
no virtual, private, or protected (since C++17) base classes
no virtual member functions

--------------
A literal type is one whose layout can be determined at compile time. The following are the literal types:

void
scalar types
references
Arrays of void, scalar types or references
A class that has a constexpr destructor, and one or more constexpr constructors that are not move or copy constructors. Additionally, all its non-static data members and base classes must be literal types and not volatile.


Specifies that a type is a literal type. Literal types are the types of constexpr variables and they can be constructed, manipulated, and returned from constexpr functions.