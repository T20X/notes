Functional programming is a style of programming that emphasizes the evaluation of expressions, rather than execution of commands. The expressions in these languages are formed by using functions to combine basic values. A functional language is a language that supports and encourages programming in a functional style.
-----------------------
Broadly speaking, FP is a style of programming in which the main program building blocks are functions as opposed to objects and procedures. A program written in the functional style doesn’t specify the commands that should be performed to achieve the result, but rather defines what the result is
-------------------------
This difference is the origin of the terms imperative and declarative programming. Imperative means you command the computer to do something by explicitly stating each step it needs to perform in order to calculate the result. Declarative means you state what should be done, and the programming language has the task of figuring out how to do it
---------------------------------------------------
he main idea when writing programs in the functional style—use abstractions that let you define the intent instead of specifying how to do something
----------------------------
The benefit of this solution is that you have fewer state variables to worry about, and you can begin to express the higher-level intent of a program instead of specifying the exact steps it needs to take to find the result
-----------------------
One of the most significant sources of software bugs is the program state. It’s difficult to keep track of all possible states a program can be in. The OOP paradigm gives you the option to group parts of the state into objects, thus making it easier to manage. But it doesn’t significantly reduce the number of possible states
--------------
It would be inefficient and counterproductive to write code in the imperative style first and then change it bit by bit until it became functional. Instead, you should think about problems differently. Instead of thinking of the algorithm steps, you should consider what the input is, what the output is, and which transformations you should perform to map one to the other
---------------------------
Functions that take other functions as arguments or that return new functions are called higher-order functions
------------------------------
Remeber!
template <template < class...> class A,   class B>
struct test1;
using test1_short = test1<std::tuple <- /*class tempalte*/, std::tuple<int,int,int> /*just class!*/>;

1.
   // Variadic template for currying
    template<typename Func, typename... Args>
    auto curry(Func func, Args... args)
    {
      return [=](auto... lastParam)
      {
        return func(args..., lastParam...);
      };
    }

   int areaOfRectangle(int length, int width)
    {
      return length * width;
    }

 auto length5 = curry(areaOfRectangle, 5);
 length5(2)

2,
   MyFunction func(a, b); 
   auto callableDiv = mem_fn(&MyFunction::division);
   auto value1 = callableDiv(func);

3. If a pure function is called multiple times with
the same arguments, it must return the same result every time and leave no trace it
was ever invoked (no side-effects). 

4. Purity improves the correctness of the
code, while expressiveness allow us to write less code in which we might make
mistakes

5. 
    template <typename T>
    using contained_type_t =
        std::remove_cv_t < std::remove_reference_t<
        decltype(*begin(std::declval<T>()))
        >>;

    template <typename C,
              typename R = contained_type_t<C>>


5. 
// the partial specialization of A is enabled via a template parameter
template<class T, class Enable = void>
class A {}; // primary template
 
template<class T>
class A<T, typename std::enable_if<std::is_floating_point<T>::value>::type> {
}; // specialization for floating point types



15. - Types are first-class values inside compile-time programs.
    - Functions at compile time live in a world where no side effects can occur
    - As per our first axiom, the only interesting values in metaprogramming are types. Thus, c    ompile-time functions are components that map types to other types.
    - compile-time containers must be types that contain zero or more other types.
    - Any template class accepting a variable number of type parameters can be considered a type container

   -  A metafunction is a class template or a template alias whose parameters are all types
   - A quoted metafunction is a class with a public metafunction member called fn, for example
    struct Q1 { template<class...> using fn = void; }
    - Dealing with compile-time containers requires no loops. Try to express your algorithm as much as possible as a direct manipulation of parameter packs.


16. he first intuition we might have coming from our runtime experience is to find a way to “loop” over types as we repeatedly call push_back. Even if it’s a correct implementation, we need to fight this compulsion of thinking with loops. Loops over types will require a linear number of intermediate types to be computed, leading to unsustainable compilation times. The correct way of handling this use case is to find a natural way to exploit the variadic nature of our containers.

17.

    template <template <class...> class A, template <class...> class F, class... T>              
    struct my_transform <A<T...>, F> { using r = A<typename F<T>::type...>;  };
    using resutlt_of_transform = my_transform<std::tuple<int, int, int>, std::add_pointer>::r;

    *VS*

    template <template <class...> class F>
    struct lambda
    {         
         template <class... Args>
         struct apply
         {
            using type = typename F<Args...>::type;
         };
    };
    
    template <class A, class F>
     struct my_transform2;

     template <template <class...> class A,
         class F, class... T>
     struct my_transform2 <A<T...>, F>
     {
         using type = A< typename F::template apply<T>::type ... >;
     };

    using resutlt_of_transform2 = my_transform2<
          std::tuple<int, int, int>,
          lambda<std::add_pointer>
        >::type;