Remeber!
template <template < class...> class A,   class B>
struct test1;
using test1_short = test1<std::tuple <- /*class tempalte*/, std::tuple<int,int,int> /*just class!*/>;

1.
   // Variadic template for currying
    template<typename Func, typename... Args>
    auto curry(Func func, Args... args)
    {
      return [=](auto... lastParam)
      {
        return func(args..., lastParam...);
      };
    }

   int areaOfRectangle(int length, int width)
    {
      return length * width;
    }

 auto length5 = curry(areaOfRectangle, 5);
 length5(2)

2,
   MyFunction func(a, b); 
   auto callableDiv = mem_fn(&MyFunction::division);
   auto value1 = callableDiv(func);

3. If a pure function is called multiple times with
the same arguments, it must return the same result every time and leave no trace it
was ever invoked (no side-effects). 

4. Purity improves the correctness of the
code, while expressiveness allow us to write less code in which we might make
mistakes

5. 
    template <typename T>
    using contained_type_t =
        std::remove_cv_t < std::remove_reference_t<
        decltype(*begin(std::declval<T>()))
        >>;

    template <typename C,
              typename R = contained_type_t<C>>


5. 
// the partial specialization of A is enabled via a template parameter
template<class T, class Enable = void>
class A {}; // primary template
 
template<class T>
class A<T, typename std::enable_if<std::is_floating_point<T>::value>::type> {
}; // specialization for floating point types

6.
 template<class T,
         typename std::enable_if<
             !std::is_trivially_destructible<T>{} &&
             (std::is_class<T>{} || std::is_union<T>{}),
            int>::type = 0>
void destroy(T* t)

7.

    template <typename C, 
        typename = void_t<>> 
        struct is_iterable 
        : std::false_type {}; 

        template <typename C> 
        struct is_iterable< 
        C, void_t<decltype(*begin(std::declval<C>())), 
        decltype(end(std::declval<C>()))>> 
        : std::true_type{};

8. template <typename T, typename... Args>
std::unique_ptr<T> make_unique_helper(std::false_type, Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

template <typename T, typename... Args>
std::unique_ptr<T> make_unique_helper(std::true_type, Args&&... args) {
   static_assert(std::extent<T>::value == 0,
       "make_unique<T[N]>() is forbidden, please use make_unique<T[]>().");

   typedef typename std::remove_extent<T>::type U;
   return std::unique_ptr<T>(new U[sizeof...(Args)]{std::forward<Args>(args)...});
}

template <typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
   return make_unique_helper<T>(std::is_array<T>(), std::forward<Args>(args)...);
}

9. 

template<class... _Types> inline
	constexpr tuple<typename _Unrefwrap<_Types>::type...>
		make_tuple(_Types&&... _Args)
	{	// make tuple from elements
	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
	return (_Ttype(_STD forward<_Types>(_Args)...));
	}

10. default template argument - typename = std::enable_if_t<std::is_integral<Integer>::value>
     default template arguments are not part of function template's signature

11. A substitution failure is any situation when the type or expression above would be ill-formed (with a required diagnostic), if written using the substituted argument

12. The compiler does overload resolution before it even looks at specialisations

Only the failures in the types and expressions in the immediate context of the function type or its template parameter types or its explicit specifier (since C++20) are SFINAE errors. If the evaluation of a substituted type/expression causes a side-effect such as instantiation of some template specialization, generation of an implicitly-defined member function, etc, errors in those side-effects are treated as hard errors

13. decval - Converts any type T to a reference type, making it possible to use member functions in decltype expressions without the need to go through constructors

14. 
template <class C, class F>
auto test(C c, F f) -> decltype((void)(c.*f)(), void())
{ std::cout << "Reference overload called\n"; }

template <class C, class F>
auto test(C c, F f) -> decltype((void)((c->*f)()), void())
{ std::cout << "Pointer overload called\n"; }

auto enableIfSINAFE(Container& v) -> decltype(enable_if_t<is_same<Iter, random_access_iterator_tag>::value>(), void())
auto enableIfSINAFE(Container& v) -> decltype(enable_if_t<is_same<Iter, bidirectional_iterator_tag>::value>(), void())

template <class _Ty1>
class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>>
void f()
16. 
template< class... >
using void_t = void;
(since C++17)
This metafunction is used in template metaprogramming to detect ill-formed types in SFINAE context

// primary template handles types that have no nested ::type member:
template< class, class = std::void_t<> >
struct has_type_member : std::false_type { };
 
// specialization recognizes types that do have a nested ::type member:
template< class T >
struct has_type_member<T, std::void_t<typename T::type>> : std::true_type { };
OR
template< class T >
struct has_type_member<T, std::void_t<decltype(T::member)> : std::true_type { };


15. - Types are first-class values inside compile-time programs.
    - Functions at compile time live in a world where no side effects can occur
    - As per our first axiom, the only interesting values in metaprogramming are types. Thus, c    ompile-time functions are components that map types to other types.
    - compile-time containers must be types that contain zero or more other types.
    - Any template class accepting a variable number of type parameters can be considered a type container

   -  A metafunction is a class template or a template alias whose parameters are all types
   - A quoted metafunction is a class with a public metafunction member called fn, for example
    struct Q1 { template<class...> using fn = void; }
    - Dealing with compile-time containers requires no loops. Try to express your algorithm as much as possible as a direct manipulation of parameter packs.


16. he first intuition we might have coming from our runtime experience is to find a way to “loop” over types as we repeatedly call push_back. Even if it’s a correct implementation, we need to fight this compulsion of thinking with loops. Loops over types will require a linear number of intermediate types to be computed, leading to unsustainable compilation times. The correct way of handling this use case is to find a natural way to exploit the variadic nature of our containers.

17.

    template <template <class...> class A, template <class...> class F, class... T>              
    struct my_transform <A<T...>, F> { using r = A<typename F<T>::type...>;  };
    using resutlt_of_transform = my_transform<std::tuple<int, int, int>, std::add_pointer>::r;

    *VS*

    template <template <class...> class F>
    struct lambda
    {         
         template <class... Args>
         struct apply
         {
            using type = typename F<Args...>::type;
         };
    };
    
    template <class A, class F>
     struct my_transform2;

     template <template <class...> class A,
         class F, class... T>
     struct my_transform2 <A<T...>, F>
     {
         using type = A< typename F::template apply<T>::type ... >;
     };

    using resutlt_of_transform2 = my_transform2<
          std::tuple<int, int, int>,
          lambda<std::add_pointer>
        >::type;