But in the C++17 standard added a new quality to a pointer value. This quality is not encode within the pointer type but qualifies directly the value, independently of the type (this is the case also of the traceability). It is described in [basic.compound]/3

Every value of pointer type is one of the following:

- a pointer to an object or function (the pointer is said to point to the object or function), or
- a pointer past the end of an object ([expr.add]), or
- the null pointer value for that type, or an invalid pointer value.

------------------------
Cannot re-create const in const!
-------------------------
Creating a new object within the storage that a const complete object with static, thread, or automatic storage duration occupies, or within the storage that such a const object used to occupy before its lifetime ended, results in undefined behavior. [?Example:
struct B {
  B();
  ~B();
};

const B b;

void h() {
  b.~B();
  new (const_cast<B*>(&b)) const/*const in const is not allowed*/ B;     // undefined behavior

---------------------------------


struct V {
  virtual void f();
};

struct A : virtual V { };

struct B : virtual V {
  B(V*, A*);
};

struct D : A, B {
  D() : B((A*)this, this) { }
};

B::B(V* v, A* a) {
  typeid(*this);        // type_�info for B
  typeid(*v);           // well-defined: *v has type V, a base of B yields type_�info for B
  typeid(*a);           //*a IS ***STILL UNDER CONSTRUCTION BECAUSE IT WAS PASSAED FROM D!*** undefined behavior: type A not a base of B
  dynamic_cast<B*>(v);  // well-defined: v of type V*, V base of B results in B*
  dynamic_cast<B*>(a);  // undefined behavior, a has type A*, A not a base of B

------------------
The storage duration is the property of an object that defines the minimum potential lifetime of the storage containing the object. The storage duration is determined by the construct used to create the object and is one of the following:
- static storage duration
- thread storage duration
- automatic storage duration
- dynamic storage duration

When storage for an object with automatic or dynamic storage duration is obtained, the object has an indeterminate value, and if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced ([expr.ass]). [?Note: Objects with static or thread storage duration are zero-initialized, see

If a variable with automatic storage duration has initialization or a destructor with side effects, an implementation shall not destroy it before the end of its block nor eliminate it as an optimization, even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified i

--------------
Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluate

When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function

A discarded-value expression is an expression that is used for its side-effects only. The value calculated from such expression is discarded. Such expressions include the full expression of any expression statement, the left-hand argument of the built-in comma operator, or the argument of a cast-expression that casts to the type void.

----------
Operator overloading shall not modify the rules for the built-in operators, that is, for operators applied to types for which they are defined by this Standard
------------------


------
implicitly created objects
-------

-----> it is either aggregate or got trival eglibible constructor  and a trivial non-deleted destructor. Note that in aggregatre if subojbect is not itself implicitly created object than it won't be created. <---------------


Certain operations may implicitly create and start the lifetime of objects of implicit-lifetime types, if doing so would prevent undefined behavior. However, such operations do not start the lifetimes of subobjects of such objects that are not themselves of implicit-lifetime types.

The following operations may implicitly create objects:

An operation that begins the lifetime of an array of unsigned char or std::byte (since C++17).
An invocation of std::aligned_alloc, (since C++17)std::calloc, std::malloc, or std::realloc.
Any implicit or explicit invocation of a function named operator new or operator new[] (including non-allocating and user-defined placement allocation functions). Including
std::allocator::allocate
std::allocator::allocate_at_least (since C++23)
(since C++17) An invocation of std::memory_resource::allocate, regardless of how storage is obtained. Including
std::pmr::polymorphic_allocator::allocate (since C++17)
std::pmr::polymorphic_allocator::allocate_bytes (since C++20)
std::pmr::polymorphic_allocator::allocate_object (since C++20)
An invocation of std::memcpy or std::memmove.
(since C++20) An invocation of std::bit_cast.
(since C++23) An invocation of std::start_lifetime_as or std::start_lifetime_as_array.
An assignment expression that involves union members if the union's assignment operator is built-in or trivial.
