regular types match primitive type semantics
we call the set of axioms satisfaying data type and a set of operations on it a concept
---------------
f(object o);
f(object(12)) - copy of object can be elided - contstructs right in o!
---------
copy/move operators and destructos ideally should not have observable side-effects as if someone is 100% relied on them being called
------------------

object f() { return 5; }
object o = f(); //only calls o ctor!
object o2 = 1;
o2 = f(); //calls ctor, ctor and copy
-------------
assignment operators ideally should provide strong exception safety gauarantee
---------------------
there is no such a polymorphic type, but the use is
-------------------
value is a correspondence between entities with common properties and a set of values
an object type is a pattern for storing a value of a corresponding value type inside the memory
an object is a representation of a concrete entity as a value in memory
we define operations in terms of the operation's semantics. choosing the same syntax for the same semantics enables code reuse
(example: assingment is a procedure of taking two same types and making the first like second one without modifying the second one)

regular types which have operations defined on them using normal names are said to have "value semantics"
regualr types which are accessed indirectly through some shared reference are said to have "reference semantics"

partially formed type - it can be destructed, it can be assigned to, but cannnot be used in other way
-------------------
classes no need to define swap function anymore really from c++14 if move operators are present as std::swap can now work well with move operators!
------
objects shall be composable
sink object ideally pass by value
objects shall be easy to move
----------------------
Pointers can have a lot of different meanings in different situations, and they’re bad at communicating what they’re used for. When you see a function that returns a pointer, you have a few options:
It’s a factory function that returns an object you’ll become the owner of.
It’s a function that returns a pointer to an existing object you don’t own.
It’s a function that can fail, and it communicates the failure by returning the null pointer as the result.
------------------------------------------------------
This is the recommended approach to designing programs with state based on sum types: put the logic that deals with one state inside the object that defines that state, and put the logic that performs state transitions into the main program
-------------------------
It’s a bad idea to ever make std::pair or std::tuple to be a part of a public API
--------------------------------
no auto for non-moveable types! auto v = type() //type has to be moveable!
------------
void set_name(string s) noexcept //never declare it like that. even function is, but it may throw at the caller end!
{ _s = std::move(s); }

it is good to pass by values in constructors! because then we may not miss the capacity the source (string/vector) already have!

forwarding references are good in functions which forwards values and then the destination function will know what to do with it

----------------------
don't use rvalue refrence optimizations (&&) and forwarding refrences by default - just stick to const & and by value parameter passing and refer to the && as an optimization given the set of use cases
-----------------------
The most important insight is that the answer depends on the details of the base class’s contract. It is not enough to know that the public interfaces / method signatures are compatible; one also needs to know if the contracts / behaviors are compatible
-------------
The important part of the previous sentence are the words “contracts / behaviors.” That phrase goes well beyond the public interface = method signatures = method names and parameter types and constness. A method’s contract means its advertised behavior = advertised requirements and promises = advertised preconditions and postconditions. So if the base class has a method void insert(const Foo& x), the contract of that method includes the signature (meaning the name insert and the parameter const Foo&), but goes well beyond that to include the method’s advertised preconditions and postconditions
------------------------
in OO, a thing is defined by how it behaves, not by the label used to name it
The derived class must do what the base class promises, not what it actually does.
The key is that we’ve separated the advertised behavior (“specification”) from implemented behavior (“implementation”)
-------------
Next insight: inheritance means “is substitutable for.” It does not mean “is a” (since that is ill defined) and it does not mean “is a kind of” (also ill defined). Substitutability is well defined: to be substitutable, the derived class is allowed (not required) to add (not remove) public methods, and for each public method inherited from the base class, the derived class is allowed (not required) to weaken preconditions and/or strengthen postconditions (not the other way around). Further the derived class is allowed to have completely different constructors, static methods, and non-public methods
-------------
You should use inheritance (a) only if the derived class’s methods can abide by all the promises made in the base class, and (b) only if you don’t think you’ll confuse your users, and (c) only if there’s something to be gained by using the inheritance — some real, measurable improvement in time, money or risk

Bad inheritances always have a base class with an extra capability (often an extra member function or two; sometimes an extra promise made by one or a combination of member functions) that a derived class can’t satisfy. You’ve either got to make the base class weaker, make the derived class stronger, or eliminate the proposed inheritance relationship. I’ve seen lots and lots and lots of these bad inheritance proposals, and believe me, they all boil down to the Circle/Ellipse example

-------------
you can make anything inherit from anything provided the methods in the derived class abide by the promises made in the base class
------------
concept based polymorphizm
----------------------
Note: decltype(auto) is primarily useful for deducing the return type of forwarding functions and similar wrappers, as shown above, where you want the type to exactly “track” some expression you’re invoking. However, decltype(auto) is not intended to be a widely used feature beyond that. In particular, although it can be used to declare local variables, doing that is probably just an antipattern since a local variable’s reference-ness should not depend on the initialization expression. Also, it is sensitive to how you write the return statement. These two functions have different return types

------------------------
Don't delete the move members

*********************************
Assuming your compiler is completely C++11 conforming,
 then explicitly deleting the move constructor will also implicitly declare the following:

Foo(const Foo&) = delete;
Foo& operator=(const Foo&) = delete;
AND YOU CANNOT ENABLE THEM BACK!
-------------------------


---------
auto for range loops
---------

I personally like to use auto&& in generic code where I need to modify 
the elements of the sequence. If I don't, I'll just stick to auto const&
-----------
So what do I recommend? Use '\n', and std::flush if you really do
mean it. You may as well put the '\n' into the preceding string literal
while you are at it.
 std::cout << "foo\n";
 std::cout << "Some int: " << i << '\n';
 std::cout << "bar\n" << std::flush;

-----------------------
Do not use throw to indicate a coding error in usage of a function. Use assert or other mechanism to either send the process into a debugger or to crash the process and collect the crash dump for the developer to debug.
Do not use throw if you discover unexpected violation of an invariant of your component, use assert or other mechanism to terminate the program. Throwing an exception will not cure memory corruption and may lead to further corruption of important user data.
-----------------------
Good example of using exceptions 

void f()  // Using exceptions
{
  try {
    GResult gg = g();
    HResult hh = h();
    IResult ii = i();
    JResult jj = j();
    // ...
  }
  catch (FooError& e) {
    // ...code that handles "foo" errors...
  }
  catch (BarError& e) {
    // ...code that handles "bar" errors...
  }
}
IMAGINE NOW checking returns codes for each function instead???
---------------------

std::any issues
 - no control over memory allocation coz no way atm on how  to store type erased memory allocator in type erased class!
- if T move constructor throws is bad as it type is erased; any(any&&) noexcept...