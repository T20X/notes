C++filt can be used to demangle names
abidiff can be used to compare two executable on ABI compatibility
-----------
Note about ABI
This text applies to most C++ ABIs used by compilers which KDE can be built with. It is mostly based on the Itanium C++ ABI Draft, which is used by the GCC C++ compiler since version 3.4 in all platforms it supports. Information about Microsoft Visual C++ mangling scheme mostly comes from this article on calling conventions (it's the most complete information found so far on MSVC ABI and name mangling).

Some of the constraints specified here may not apply to a given compiler. The goal here is to list the most restrictive set of conditions when writing cross-platform C++ code, meant to be compiled with several different compilers.

This page is updated when new binary incompatibility issues are found.

The Do's and Don'ts
You can...

add new non-virtual functions including signals and slots and constructors.
add a new enum to a class.
append new enumerators to an existing enum.
Exeption: if that leads to the compiler choosing a larger underlying type for the enum, that makes the change binary-incompatible. Unfortunately, compilers have some leeway to choose the underlying type, so from an API-design perspective it's recommended to add a Max.... enumerator with an explicit large value (=255, =1<<15, etc) to create an interval of numeric enumerator values that is guaranteed to fit into the chosen underlying type, whatever that may be.
reimplement virtual functions defined in the primary base class hierarchy (that is, virtuals defined in the first non-virtual base class, or in that class's first non-virtual base class, and so forth) if it is safe that programs linked with the prior version of the library call the implementation in the base class rather than the derived one. This is tricky and might be dangerous. Think twice before doing it. Alternatively see below for a workaround.
Exception: if the overriding function has a covariant return type, it's only a binary-compatible change if the more-derived type has always the same pointer address as the less-derived one. If in doubt, do not override with a covariant return type.
change an inline function or make an inline function non-inline if it is safe that programs linked with the prior version of the library call the old implementation. This is tricky and might be dangerous. Think twice before doing it.
remove private non-virtual functions if they are not called by any inline functions (and have never been).
remove private static members if they are not called by any inline functions (and have never been).
add new static data members.
change the default arguments of a method. It requires recompilation to use the actual new default argument values, though.
add new classes.
export a class that was not previously exported.
add or remove friend declarations to classes.
rename reserved member types
extend reserved bit fields, provided this doesn't cause the bit field to cross the boundary of its underlying type (8 bits for char & bool, 16 bits for short, 32 bits for int, etc.)
add the Q_OBJECT macro to a class if the class already inherits from QObject
add a Q_PROPERTY, Q_ENUMS or Q_FLAGS macro as that only modifies the meta-object generated by moc and not the class itself
You cannot...

For existing classes:
unexport or remove an exported class.
change the class hierachy in any way (add, remove, or reorder base classes).
Remove finality
For template classes:
change the template arguments in any way (add, remove or reorder).
For existing functions of any type:
unexport it.
remove it.
Remove the implementation of existing declared functions. The symbol comes from the implementation of the function, so this is effectively the function.
inline it (this includes moving a member function's body to the class definition, even without the inline keyword).
add an overload (BC, but not SC: makes &func ambiguous), adding overloads to already overloaded functions is ok (any use of &func already needed a cast).
change its signature. This includes:
changing any of the types of the arguments in the parameter list, including changing the const/volatile qualifiers of the existing parameters (instead, add a new method)
changing the const/volatile qualifiers of the function
changing the access rights to some functions or data members, for example from private to public. With some compilers, this information may be part of the signature. If you need to make a private function protected or even public, you have to add a new function that calls the private one.
changing the CV-qualifiers of a member function: the const and/or volatile that apply to the function itself.
extending a function with another parameter, even if this parameter has a default argument. See below for a suggestion on how to avoid this issue
changing the return type in any way
Exception: non-member functions declared with extern "C" can change parameter types (be very careful).
For virtual member functions:
add a virtual function to a class that doesn't have any virtual functions or virtual bases.
add new virtual functions to non-leaf classes as this will break subclasses. Note that a class designed to be subclassed by applications is always a non-leaf class. See below for some workarounds or ask on mailing lists.
add new virtual functions for any reason, even to leaf classes, if the class is intended to remain binary compatible on Windows. Doing so may reorder existing virtual functions and break binary compatibility.
change the order of virtual functions in the class declaration.
override an existing virtual function if that function is not in the primary base class (first non-virtual base class, or the primary base class's primary base class and upwards).
override an existing virtual function if the overriding function has a covariant return type for which the more-derived type has a pointer address different from the less-derived one (usually happens when, between the less-derived and the more-derived ones, there's multiple inheritance or virtual inheritance).
Remove a virtual function, even if it is a reimplementation of a virtual function from the base class
For static non-private members or for non-static non-member public data:
Remove or unexport it
Change its type
Change its CV-qualifiers
For non-static members:
add new, data members to an existing class.
change the order of non-static data members in a class.
change the type of the member, except for signedness
remove existing non-static data members from an existing clas
-------------
Array Operator new Cookies
When operator new is used to create a new array, a cookie is usually stored to remember the allocated length (number of array elements) so that it can be deallocated correctly.

Specifically:

No cookie is required if the array element type T has a trivial destructor (12.4 [class.dtor]) and the usual (array) deallocation function (3.7.3.2 [basic.stc.dynamic.deallocation]) function does not take two arguments.
(Note: if the usual array deallocation function takes two arguments, then it is a member function whose second argument is of type size_t. The standard guarantees (12.5 [class.free]) that this function will be passed the number of bytes allocated with the previous array new expression.)

No cookie is required if the new operator being used is ::operator new[](size_t, void*).
Otherwise, this ABI requires a cookie, setup as follows:
The cookie will have size sizeof(size_t).
Let align be the maximum alignment of size_t and an element of the array to be allocated.
Let padding be the maximum of sizeof(size_t) and align bytes.
The space allocated for the array will be the space required by the array itself plus padding bytes.
The alignment of the space allocated for the array will be align bytes.
The array data will begin at an offset of align bytes from the space allocated for the array.
The cookie will be stored in the sizeof(size_t) bytes immediately preceding the array data.
These rules have the following consequences:

The array elements and the cookie are all aligned naturally.
Padding will be required if sizeof(size_t) is smaller than the array element alignment, and if present will precede the cookie.
Given the above, the following is pseudocode for processing new(ARGS) T[n]:

  if T has a trivial destructor (C++ standard, 12.4/3)
    padding = 0
  else if we're using ::operator new[](size_t, void*)
    padding = 0
  else
    padding = max(sizeof(size_t), alignof(T))

  p = operator new[](n * sizeof(T) + padding, ARGS)
  p1 = (T*) ( (char *)p + padding )

  if padding > 0
    *( (size_t *)p1 - 1) = n

  for i = [0, n)
    create a T, using the default constructor, at p1[i]

  return p1