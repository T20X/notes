Function parameters are typically passed in registers. See the ABI link at the beginning of this answer for details, but in short, integral types and pointers are passed in registers %rdi, %rsi, %rdx, %rcx, %r8, and %r9, with floating-point arguments in the %xmm0 to %xmm7 registers
-----------
C++filt can be used to demangle names
abidiff can be used to compare two executable on ABI compatibility
-----------
Note about ABI
This text applies to most C++ ABIs used by compilers which KDE can be built with. It is mostly based on the Itanium C++ ABI Draft, which is used by the GCC C++ compiler since version 3.4 in all platforms it supports. Information about Microsoft Visual C++ mangling scheme mostly comes from this article on calling conventions (it's the most complete information found so far on MSVC ABI and name mangling).

Some of the constraints specified here may not apply to a given compiler. The goal here is to list the most restrictive set of conditions when writing cross-platform C++ code, meant to be compiled with several different compilers.

This page is updated when new binary incompatibility issues are found.

The Do's and Don'ts
You can...

add new non-virtual functions including signals and slots and constructors.
add a new enum to a class.
append new enumerators to an existing enum.
Exeption: if that leads to the compiler choosing a larger underlying type for the enum, that makes the change binary-incompatible. Unfortunately, compilers have some leeway to choose the underlying type, so from an API-design perspective it's recommended to add a Max.... enumerator with an explicit large value (=255, =1<<15, etc) to create an interval of numeric enumerator values that is guaranteed to fit into the chosen underlying type, whatever that may be.
reimplement virtual functions defined in the primary base class hierarchy (that is, virtuals defined in the first non-virtual base class, or in that class's first non-virtual base class, and so forth) if it is safe that programs linked with the prior version of the library call the implementation in the base class rather than the derived one. This is tricky and might be dangerous. Think twice before doing it. Alternatively see below for a workaround.
Exception: if the overriding function has a covariant return type, it's only a binary-compatible change if the more-derived type has always the same pointer address as the less-derived one. If in doubt, do not override with a covariant return type.
change an inline function or make an inline function non-inline if it is safe that programs linked with the prior version of the library call the old implementation. This is tricky and might be dangerous. Think twice before doing it.
remove private non-virtual functions if they are not called by any inline functions (and have never been).
remove private static members if they are not called by any inline functions (and have never been).
add new static data members.
change the default arguments of a method. It requires recompilation to use the actual new default argument values, though.
add new classes.
export a class that was not previously exported.
add or remove friend declarations to classes.
rename reserved member types
extend reserved bit fields, provided this doesn't cause the bit field to cross the boundary of its underlying type (8 bits for char & bool, 16 bits for short, 32 bits for int, etc.)
add the Q_OBJECT macro to a class if the class already inherits from QObject
add a Q_PROPERTY, Q_ENUMS or Q_FLAGS macro as that only modifies the meta-object generated by moc and not the class itself
You cannot...

For existing classes:
unexport or remove an exported class.
change the class hierachy in any way (add, remove, or reorder base classes).
Remove finality
For template classes:
change the template arguments in any way (add, remove or reorder).
For existing functions of any type:
unexport it.
remove it.
Remove the implementation of existing declared functions. The symbol comes from the implementation of the function, so this is effectively the function.
inline it (this includes moving a member function's body to the class definition, even without the inline keyword).
add an overload (BC, but not SC: makes &func ambiguous), adding overloads to already overloaded functions is ok (any use of &func already needed a cast).
change its signature. This includes:
changing any of the types of the arguments in the parameter list, including changing the const/volatile qualifiers of the existing parameters (instead, add a new method)
changing the const/volatile qualifiers of the function
changing the access rights to some functions or data members, for example from private to public. With some compilers, this information may be part of the signature. If you need to make a private function protected or even public, you have to add a new function that calls the private one.
changing the CV-qualifiers of a member function: the const and/or volatile that apply to the function itself.
extending a function with another parameter, even if this parameter has a default argument. See below for a suggestion on how to avoid this issue
changing the return type in any way
Exception: non-member functions declared with extern "C" can change parameter types (be very careful).
For virtual member functions:
add a virtual function to a class that doesn't have any virtual functions or virtual bases.
add new virtual functions to non-leaf classes as this will break subclasses. Note that a class designed to be subclassed by applications is always a non-leaf class. See below for some workarounds or ask on mailing lists.
add new virtual functions for any reason, even to leaf classes, if the class is intended to remain binary compatible on Windows. Doing so may reorder existing virtual functions and break binary compatibility.
change the order of virtual functions in the class declaration.
override an existing virtual function if that function is not in the primary base class (first non-virtual base class, or the primary base class's primary base class and upwards).
override an existing virtual function if the overriding function has a covariant return type for which the more-derived type has a pointer address different from the less-derived one (usually happens when, between the less-derived and the more-derived ones, there's multiple inheritance or virtual inheritance).
Remove a virtual function, even if it is a reimplementation of a virtual function from the base class
For static non-private members or for non-static non-member public data:
Remove or unexport it
Change its type
Change its CV-qualifiers
For non-static members:
add new, data members to an existing class.
change the order of non-static data members in a class.
change the type of the member, except for signedness
remove existing non-static data members from an existing clas
-------------
Array Operator new Cookies
When operator new is used to create a new array, a cookie is usually stored to remember the allocated length (number of array elements) so that it can be deallocated correctly.

Specifically:

No cookie is required if the array element type T has a trivial destructor (12.4 [class.dtor]) and the usual (array) deallocation function (3.7.3.2 [basic.stc.dynamic.deallocation]) function does not take two arguments.
(Note: if the usual array deallocation function takes two arguments, then it is a member function whose second argument is of type size_t. The standard guarantees (12.5 [class.free]) that this function will be passed the number of bytes allocated with the previous array new expression.)

No cookie is required if the new operator being used is ::operator new[](size_t, void*).
Otherwise, this ABI requires a cookie, setup as follows:
The cookie will have size sizeof(size_t).
Let align be the maximum alignment of size_t and an element of the array to be allocated.
Let padding be the maximum of sizeof(size_t) and align bytes.
The space allocated for the array will be the space required by the array itself plus padding bytes.
The alignment of the space allocated for the array will be align bytes.
The array data will begin at an offset of align bytes from the space allocated for the array.
The cookie will be stored in the sizeof(size_t) bytes immediately preceding the array data.
These rules have the following consequences:

The array elements and the cookie are all aligned naturally.
Padding will be required if sizeof(size_t) is smaller than the array element alignment, and if present will precede the cookie.
Given the above, the following is pseudocode for processing new(ARGS) T[n]:

  if T has a trivial destructor (C++ standard, 12.4/3)
    padding = 0
  else if we're using ::operator new[](size_t, void*)
    padding = 0
  else
    padding = max(sizeof(size_t), alignof(T))

  p = operator new[](n * sizeof(T) + padding, ARGS)
  p1 = (T*) ( (char *)p + padding )

  if padding > 0
    *( (size_t *)p1 - 1) = n

  for i = [0, n)
    create a T, using the default constructor, at p1[i]

  return p1

  ------------------

  Symbol table .symtab contains 1203 entries:

 Num:    Value  Size Type    Bind   Vis      Ndx Name
 310: a0008120     0 NOTYPE  GLOBAL DEFAULT  ABS _gp  
 734: a0000010    32 OBJECT  GLOBAL DEFAULT   77 v 
 818: 9d000018   496 FUNC    GLOBAL DEFAULT   71 main 
 849: a0000124     4 OBJECT  GLOBAL DEFAULT   78 phrase 
 955: a0000000     9 OBJECT  GLOBAL DEFAULT   77 peppers  
1020: a000023c   192 OBJECT  GLOBAL DEFAULT   80 bins
Num: = The symbol number
Value = The address of the Symbol
Size = The size of the symbol
Type = symbol type: Func = Function, Object, File (source file name), Section = memory section, Notype = untyped absolute symbol or undefined
Bind = GLOBAL binding means the symbol is visible outside the file. LOCAL binding is visible only in the file. WEAK is like global, the symbol can be overridden.
Vis = Symbols can be default, protected, hidden or internal.
Ndx = The section number the symbol is in. ABS means absolute: not adjusted to any section address's relocation
Name = symbol name


maine@maine-VirtualBox:~/cpp_snippets/inline$ readelf -h app
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               --------->0x400540  <----

readelf -l app

Elf file type is EXEC (Executable file)
Entry point 0x4005d0
There are 9 program headers, starting at offset 64
An executable or shared object file's program header table is an
       array of structures, each describing a segment or other information
       the system needs to prepare the program for execution.  An object
       file segment contains one or more sections.  Program headers are
       meaningful only for executable and shared object files


Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x00000000000001f8 0x00000000000001f8  R      0x8
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000a10 0x0000000000000a10  R E    0x200000
  LOAD           0x0000000000000db8 0x0000000000600db8 0x0000000000600db8
                 0x0000000000000298 0x00000000000002a0  RW     0x200000
  DYNAMIC        0x0000000000000dd0 0x0000000000600dd0 0x0000000000600dd0
                 0x0000000000000220 0x0000000000000220  RW     0x8
  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                 0x0000000000000020 0x0000000000000020  R      0x4
  GNU_EH_FRAME   0x00000000000007e4 0x00000000004007e4 0x00000000004007e4
                 0x000000000000006c 0x000000000000006c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000000db8 0x0000000000600db8 0x0000000000600db8
                 0x0000000000000248 0x0000000000000248  R      0x1

Program headers map sections into segment like this! (the order does matter and they are layed in the memory in the exact same order. you can verify that if you check addresses in the sections)
 Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame
   03     .init_array .fini_array .dynamic .got .got.plt .data .bss
   04     .dynamic
   05     .note.ABI-tag
   06     .eh_frame_hdr
   07
   08     .init_array .fini_array .dynamic .got




 readelf -S app

    [13] .text             PROGBITS         0000000000--->400540<---  00000540(offset from the start of the file!)
       00000000000001e2(absolute section size)  0000000000000000  AX       0     0     16


       position between 0x400000 and entry point is used for the EHDR and PHDR, meaning ELF headers and Program Headers. We'll look into this in detail later


       maine@maine-VirtualBox:~/cpp_snippets/inline$ cat /proc/30203/maps
00400000-00401000 r-xp 00000000 08:01 405746  (text segment)                           /home/maine/cpp_snippets/inline/app
00600000-00601000 r--p 00000000 08:01 405746   (data segment)                          /home/maine/cpp_snippets/inline/app
00601000-00602000 rw-p 00001000 08:01 405746   (bss segment)                          /home/maine/cpp_snippets/inline/app
01732000-01753000 rw-p 00000000 00:00 0    


objdump -t symbols.o - symbold table of the object file!
Disassembly of section .text:
0000000000000000 <_start-0x28>:
   0:   48 b8 00 00 00 00 00      movabs rax,0x0
   7:   00 00 00
   a:   48 b8 00 00 00 00 00      movabs rax,0x0
   11:  00 00 00
   14:  48 b8 00 00 00 00 00      movabs rax,0x0
   1b:  00 00 00
   1e:  48 ba 00 00 00 00 00      movabs rdx,0x0
   25:  00 00 00
0000000000000028 <_start>:
   28:  c3                        ret
0000000000000029 <textlabel>:
The mov operand in section .text with offsets 0 and 14 relative to section start should be datavar1 address , but it is equal to zero! The same thing happened with bssvar. It means that the linker has to change compiled machine code, filling the right absolute addresses in instruction arguments. To achieve that, for each symbol all references to it are remembered in relocation table . As soon as the linker understands what its true virtual address will be, it goes through the list of symbol occurrences and fills in the holes.

A separate relocation table exists for each section in need of one.

To see the relocation tables use readelf --relocs. See Listing 5-25.

Listing 5-25. readelf_relocs
> readelf --relocs  main.o
Relocation section '.rela.text' at offset 0x440 contains 4 entries:
  Offset          Info       Type            Sym. Value    Name+Addend
000000000002  000200000001 R_X86_64_64       0000000000000000 .data + 0
00000000000c  000300000001 R_X86_64_64       0000000000000000 .bss + 0

000000000016  000300000001 R_X86_64_64       0000000000000000 .bss + 2000000
000000000020  000200000001 R_X86_64_64       0000000000000000 .data + 8



readelf --dyn-syms libso.so